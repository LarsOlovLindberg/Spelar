<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>spelar.eu</title>
  <meta name="description" content="Systematisk, riskkontrollerad edge-handel på oavgjort (Draw) via Polymarket." />

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">

  <style>
    :root{
      /* Dark mode (deep navy, VS Code/Discord-ish) */
      /* slightly darker, more “marine navy” */
      --bg:#081226;
      --panel:#0f1b33;
      --panel2:#0b2a4a;
      --panelHover:#132545;
      --text:#e2e8f0;
      --muted:#94a3b8;
      --placeholder: rgba(148,163,184,.75);
      --border:#334155;
      /* clearer cyan accent + brighter green status */
      --accent:#38bdf8;
      --good:#22c55e;
      --bad:#ef4444;
      --warn:#f59e0b;
      --shadow: 0 14px 36px rgba(0,0,0,.42);
      --shadowSoft: 0 8px 18px rgba(0,0,0,.28);
      --radius: 12px;
      --font: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:var(--font);
      font-size:16px;
      background: var(--bg);
      color:var(--text);
      font-variant-numeric: tabular-nums lining-nums;
    }

    .app{
      display:grid;
      grid-template-columns: 320px 1fr;
      min-height:100vh;
    }

    /* Sidebar */
    .sidebar{
      position:sticky;
      top:0;
      height:100vh;
      padding:18px 14px;
      background: linear-gradient(180deg, color-mix(in srgb, var(--bg) 80%, #000 20%), color-mix(in srgb, var(--bg) 92%, #000 8%));
      border-right:1px solid color-mix(in srgb, var(--border) 85%, transparent);
      overflow:auto;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      padding:12px 12px 14px 12px;
      border:1px solid color-mix(in srgb, var(--border) 80%, transparent);
      background: color-mix(in srgb, var(--panel) 88%, var(--bg) 12%);
      border-radius: 14px;
      box-shadow: none;
      margin-bottom:14px;
    }
    .logo{
      width:36px;height:36px;border-radius:12px;
      background: linear-gradient(135deg, rgba(59,130,246,.95), rgba(22,163,74,.85));
      display:grid;place-items:center;
      color:#ffffff;font-weight:800;
      letter-spacing:.5px;
      user-select:none;
    }
    .brand h1{
      font-size:22px;
      margin:0;
      line-height:1.1;
    }
    .brand small{
      display:block;
      margin-top:3px;
      color:var(--muted);
      font-size:16px;
      font-family:var(--mono);
    }

    .search{
      margin:10px 0 12px 0;
      display:flex;
      gap:8px;
      align-items:center;
      padding:10px 10px;
      border:1px solid var(--border);
      background: var(--panel);
      border-radius: 12px;
      box-shadow: var(--shadowSoft);
    }
    .search input{
      width:100%;
      border:0;
      outline:0;
      background:transparent;
      color:var(--text);
      font-size:18px;
    }
    .search input::placeholder{color:var(--placeholder)}

    .nav{
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .nav-section{
      border:0;
      background: transparent;
      border-radius: 0;
      overflow:visible;
      box-shadow: none;
      padding-bottom: 10px;
      border-bottom: 1px solid color-mix(in srgb, var(--border) 70%, transparent);
    }
    .nav-section .sec-title{
      padding:12px 6px 8px 6px;
      font-size:13px;
      color:var(--muted);
      letter-spacing:.08em;
      text-transform:uppercase;
      border-bottom:0;
      background: transparent;
    }
    .nav-items{padding:2px 0}
    .nav a{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      margin:4px 0;
      text-decoration:none;
      color:var(--text);
      border-radius: 12px;
      border:1px solid transparent;
      font-size:17px;
      font-weight:600;
      position:relative;
      background: color-mix(in srgb, var(--panel) 30%, transparent);
    }
    .nav a:hover{
      background: color-mix(in srgb, var(--accent) 10%, transparent);
      border-color: color-mix(in srgb, var(--accent) 28%, transparent);
    }
    .nav a.active{
      background: color-mix(in srgb, var(--accent) 14%, transparent);
      border-color: color-mix(in srgb, var(--accent) 34%, transparent);
      box-shadow: none;
    }
    .nav a.active::before{
      content:"";
      position:absolute;
      left: -2px;
      top: 8px;
      bottom: 8px;
      width: 4px;
      border-radius: 99px;
      background: var(--accent);
      box-shadow: 0 0 18px color-mix(in srgb, var(--accent) 45%, transparent);
    }
    .badge{
      font-size:12px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid color-mix(in srgb, var(--border) 85%, transparent);
      background: color-mix(in srgb, var(--panel2) 45%, transparent);
      color: color-mix(in srgb, var(--muted) 92%, var(--text) 8%);
      font-family:var(--font);
      user-select:none;
      white-space:nowrap;
    }

    .footer{
      margin-top:12px;
      padding:10px 12px;
      color:var(--muted);
      font-size:15px;
      border:1px dashed var(--border);
      border-radius: var(--radius);
      background: var(--panel2);
    }
    .footer code{font-family:var(--mono);color:var(--muted)}
    .footer .row{display:flex;justify-content:space-between;gap:10px;margin-top:6px}
    .dot{width:8px;height:8px;border-radius:99px;background:var(--warn);display:inline-block}
    .dot.ok{background:var(--good)}
    .dot.warn{background:var(--warn)}
    .dot.bad{background:var(--bad)}

    .statusBadge{
      display:inline-flex;
      align-items:center;
      font-family:var(--mono);
      font-size:13px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--border);
      background: var(--panel);
      color: var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    .statusBadge.ok{color:var(--good)}
    .statusBadge.warn{color:var(--warn)}
    .statusBadge.bad{color:var(--bad)}

    /* Main */
    .main{
      padding:18px 18px 32px 18px;
      overflow:auto;
    }

    .topbar{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      padding:14px 14px;
      border:0;
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: var(--shadowSoft);
      margin-bottom:14px;
    }

    .crumbs{
      font-size:15px;
      color:var(--muted);
      letter-spacing:.02em;
    }
    .title{
      margin:6px 0 0 0;
      font-size:34px;
      line-height:1.2;
    }

    .kpi{
      font-size:44px;
      font-weight:800;
      letter-spacing:-0.02em;
      line-height:1.05;
      font-variant-numeric: tabular-nums lining-nums;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }

    .actions{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    button, .btn{
      border:1px solid var(--border);
      background: color-mix(in srgb, var(--text) 6%, transparent);
      color:var(--text);
      padding:9px 11px;
      border-radius: 12px;
      cursor:pointer;
      font-size:16px;
      text-decoration:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    button:hover, .btn:hover{
      border-color: color-mix(in srgb, var(--accent) 55%, var(--border));
      background: color-mix(in srgb, var(--accent) 18%, transparent);
    }

    .content{
      border:0;
      border-radius: var(--radius);
      background: color-mix(in srgb, var(--bg) 62%, var(--panel2) 38%);
      border:1px solid var(--border);
      box-shadow: none;
      padding:16px;
      min-height: calc(100vh - 18px - 14px - 18px - 100px);
    }

    /* Ops / Live verification panel */
    .opsbar{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:12px;
      padding:14px;
      border:0;
      border-radius: var(--radius);
      background: var(--panel);
      box-shadow: var(--shadowSoft);
      margin-bottom:14px;
    }
    .opsbar h3{
      margin:0 0 6px 0;
      font-size:22px;
      color:var(--text);
    }
    .opsbar p{
      margin:6px 0;
      color:var(--text);
      line-height:1.55;
    }
    .opssteps{
      margin:8px 0 0 18px;
      color:var(--text);
    }
    .opssteps li{margin:6px 0}
    .opsright{
      border-left:1px solid var(--border);
      padding-left:12px;
    }
    .liveSummary{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-top:2px;
      color:var(--muted);
      font-size:16px;
    }
    .filelist{margin-top:10px}
    .fileRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border:1px solid var(--border);
      border-radius:12px;
      background: var(--panel2);
      margin:8px 0;
    }
    .fileRow .left{display:flex;align-items:center;gap:10px;min-width:0}
    .fileRow .name{font-family:var(--mono);font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .fileRow .meta{font-family:var(--mono);font-size:15px;color:var(--muted);white-space:nowrap}
    .fileRow .name{font-family:var(--mono);font-size:15px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .notice{
      border:1px solid color-mix(in srgb, var(--accent) 35%, transparent);
      background: color-mix(in srgb, var(--accent) 12%, transparent);
      border-radius: 12px;
      padding:12px 12px;
      margin-bottom:14px;
    }
    .notice strong{color:var(--text)}
    .notice a{color:var(--accent)}
    .notice .mono{color:var(--text)}

    /* Generic content styling */
    h2{margin:0 0 10px 0;font-size:30px;color:var(--text)}
    h3{margin:18px 0 8px 0;font-size:22px;color:var(--text)}
    p{margin:8px 0;color:var(--text);line-height:1.7}
    ul{margin:8px 0 8px 18px;color:var(--text)}
    li{margin:6px 0}
    code, pre{font-family:var(--mono)}
    pre{
      margin:10px 0;
      padding:12px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: var(--panel2);
      overflow:auto;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:16px;
      margin-top:12px;
    }
    .card{
      grid-column: span 6;
      border:0;
      border-radius: var(--radius);
      background: var(--panel);
      padding:18px;
      box-shadow: var(--shadowSoft);
      border:1px solid var(--border);
      position:relative;
      transition: none;
    }
    .card:hover{
      background: var(--panelHover);
      border-color: color-mix(in srgb, var(--accent) 55%, var(--border));
      box-shadow: var(--shadowSoft);
    }
    .card h4{margin:0 0 8px 0;font-size:18px;color:var(--text)}
    .kv{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:8px;
      color:var(--muted);
      font-size:16px;
    }
    .kv strong{color:var(--text);font-weight:600}
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size:16px;
      padding:6px 10px;
      border-radius: 999px;
      border:1px solid var(--border);
      background: var(--panel2);
      color:var(--text);
    }

    /* Shared “panel hover pop” for all boxes */
    .brand,
    .search,
    .nav-section,
    .topbar,
    .opsbar,
    .cc-shell,
    .statusBadge,
    .fileRow,
    .notice{
      position:relative;
      transition: none;
    }

    /* Ensure key panels actually have a border that can accent on hover */
    .nav-section,
    .topbar,
    .opsbar{
      border:1px solid var(--border);
    }

    .brand:hover,
    .search:hover,
    .nav-section:hover,
    .topbar:hover,
    .opsbar:hover,
    .cc-shell:hover,
    .statusBadge:hover,
    .fileRow:hover,
    .notice:hover{
      border-color: var(--accent);
      z-index: 5;
    }

    @media (prefers-reduced-motion: reduce){
      .brand,.search,.nav-section,.topbar,.opsbar,.cc-shell,.statusBadge,.fileRow,.notice,.card{transition:none}
      .brand:hover,.search:hover,.nav-section:hover,.topbar:hover,.opsbar:hover,.cc-shell:hover,.statusBadge:hover,.fileRow:hover,.notice:hover,.card:hover{transform:none}
    }

    /* Command Center (headline view) */
    .cc{
      max-width: 980px;
      margin: 0 auto;
    }
    .cc-shell{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadowSoft);
      padding: 26px;
    }
    .cc-hero{
      text-align: center;
      padding: 6px 0 8px 0;
    }
    .cc-status{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:6px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--panel2);
      font-family: var(--mono);
      font-size: 14px;
      color: var(--muted);
      user-select:none;
    }
    .cc-status.ok{ color: var(--good); }
    .cc-status.warn{ color: var(--warn); }
    .cc-status.bad{ color: var(--bad); }

    .cc-pulse{
      width:10px;height:10px;
      border-radius:999px;
      background: currentColor;
      box-shadow: 0 0 0 0 color-mix(in srgb, currentColor 45%, transparent);
      animation: none;
    }

    @keyframes ccPulse{
      0%   { box-shadow: 0 0 0 0   color-mix(in srgb, currentColor 45%, transparent); }
      70%  { box-shadow: 0 0 0 12px color-mix(in srgb, currentColor 0%, transparent); }
      100% { box-shadow: 0 0 0 0   color-mix(in srgb, currentColor 0%, transparent); }
    }

    .cc-equity{
      margin: 14px 0 6px 0;
      font-size: 64px;
      font-weight: 900;
      letter-spacing: -0.04em;
      line-height: 1.0;
      font-variant-numeric: tabular-nums lining-nums;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }
    .cc-sub{
      color: var(--muted);
      font-size: 18px;
      margin-top: 6px;
    }

    .cc-metrics{
      margin-top: 18px;
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
    }
    .cc-metric{
      grid-column: span 4;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel2) 72%, var(--bg) 28%);
      border-radius: 14px;
      padding: 14px 14px;
    }
    .cc-metric h4{ margin: 0 0 6px 0; font-size: 16px; color: var(--muted); letter-spacing: .02em; }
    .cc-metric .kpi{ font-size: 36px; font-weight: 900; letter-spacing: -0.02em; line-height: 1.05; }
    .cc-mini{ font-size: 15px; color: var(--muted); line-height: 1.45; }

    .cc-feed{
      margin-top: 18px;
      display:flex;
      flex-direction:column;
      gap: 12px;
    }
    .cc-event{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel2) 72%, var(--bg) 28%);
      border-radius: 14px;
      padding: 14px 14px;
      box-shadow: none;
    }

    .cc-poslist{
      margin-top: 10px;
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
    }
    .cc-pos{
      grid-column: span 6;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel2) 72%, var(--bg) 28%);
      border-radius: 14px;
      padding: 14px 14px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
    }
    .cc-pos .title{ margin:0; font-size:16px; font-weight:800; line-height:1.25; }
    .cc-pos .meta{ margin:6px 0 0 0; color:var(--muted); font-size:14px; line-height:1.4; }
    .cc-tags{ display:flex; flex-direction:column; gap:8px; align-items:flex-end; }
    .cc-tag{
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-family: var(--mono);
      font-size: 13px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text);
      white-space:nowrap;
      user-select:none;
    }
    .cc-tag.good{ border-color: color-mix(in srgb, var(--good) 35%, var(--border) 65%); }
    .cc-tag.warn{ border-color: color-mix(in srgb, var(--warn) 35%, var(--border) 65%); }
    .cc-tag.bad{ border-color: color-mix(in srgb, var(--bad) 35%, var(--border) 65%); }

    @media (max-width: 860px){
      .cc-pos{ grid-column: span 12; }
    }

    .cc-section{
      margin-top: 16px;
      border: 1px solid var(--border);
      background: color-mix(in srgb, var(--panel2) 68%, var(--bg) 32%);
      border-radius: 14px;
      padding: 14px 14px;
    }
    .cc-section h4{
      margin: 0 0 10px 0;
      font-size: 16px;
      color: var(--muted);
      letter-spacing: .04em;
      text-transform: uppercase;
    }
    .cc-facts{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 12px;
    }
    .cc-fact{
      grid-column: span 3;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px 12px;
    }
    .cc-fact.wide{ grid-column: span 12; }
    .cc-fact .label{ font-size: 13px; color: var(--muted); letter-spacing: .02em; }
    .cc-fact .value{ margin-top: 4px; font-size: 22px; font-weight: 900; letter-spacing: -0.01em; }
    .cc-fact .sub{ margin-top: 4px; font-size: 13px; color: var(--muted); }

    .cc-pills{ display:flex; flex-wrap:wrap; gap: 8px; margin-top: 10px; }
    .cc-pill{ border: 1px solid var(--border); background: var(--panel); border-radius: 999px; padding: 6px 10px; font-size: 14px; color: var(--text); }
    .cc-pill.ok{ border-color: color-mix(in srgb, var(--good) 35%, var(--border) 65%); }
    .cc-pill.warn{ border-color: color-mix(in srgb, var(--warn) 35%, var(--border) 65%); }
    .cc-pill.bad{ border-color: color-mix(in srgb, var(--bad) 35%, var(--border) 65%); }

    /* Simple tooltip for metrics */
    .hasTip{ position:relative; cursor: help; }
    .cc-metric.hasTip:hover,
    .cc-fact.hasTip:hover,
    .cc-event.hasTip:hover{
      border-color: color-mix(in srgb, var(--accent) 28%, var(--border) 72%);
      background: color-mix(in srgb, var(--panel2) 76%, var(--bg) 24%);
    }
    .cc-pill.hasTip:hover{
      border-color: color-mix(in srgb, var(--accent) 28%, var(--border) 72%);
    }
    .hasTip::after{
      content: attr(data-tip);
      position:absolute;
      top: calc(100% + 10px);
      left: 50%;
      transform: translateX(-50%) translateY(6px);
      width: max-content;
      max-width: min(720px, 94vw);
      padding: 14px 16px;
      border-radius: 14px;
      border: 1px solid color-mix(in srgb, var(--accent) 24%, var(--border) 76%);
      background: var(--panel);
      box-shadow: var(--shadowSoft);
      color: var(--text);
      font-family: var(--font);
      font-size: 15px;
      line-height: 1.5;
      white-space: pre-wrap;
      text-align: left;
      z-index: 60;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .hasTip::before{
      content: "";
      position:absolute;
      top: calc(100% + 4px);
      left: 50%;
      transform: translateX(-50%) translateY(6px);
      width: 0; height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 8px solid var(--panel);
      filter: drop-shadow(0 -1px 0 var(--border));
      z-index: 61;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .hasTip:hover::after,
    .hasTip:hover::before,
    .hasTip:focus::after,
    .hasTip:focus::before,
    .hasTip:focus-within::after,
    .hasTip:focus-within::before{
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }
    .cc-event .left{ min-width:0; }
    .cc-event .title{ margin:0; font-size:18px; font-weight:800; }
    .cc-event .meta{ margin:4px 0 0 0; color: var(--muted); font-size: 15px; }
    .cc-event .right{ display:flex; flex-direction:column; align-items:flex-end; gap:6px; }
    .cc-event .when{ color: var(--muted); font-family: var(--mono); font-size: 13px; }

    @media (max-width: 980px){
      .cc-equity{ font-size: 54px; }
      .cc-metric{ grid-column: span 12; }
      .cc-fact{ grid-column: span 12; }
    }

    /* Edge calculator */
    .edgecalc{
      margin-top:10px;
    }
    .edgecalc .row{
      display:flex;
      justify-content:space-between;
      gap:12px;
      align-items:flex-start;
      margin-bottom:10px;
    }
    .edgecalc .title{font-size:16px;margin:0;color:var(--text)}
    .edgecalc .sub{font-size:14px;margin:0;color:var(--muted)}
    .edgecalc .net{
      text-align:right;
      min-width:140px;
    }
    .edgecalc .net .label{font-size:12px;letter-spacing:.08em;text-transform:uppercase;color:var(--muted);font-weight:700}
    .edgecalc .net .value{font-size:34px;font-weight:900;line-height:1.05}

    /* Ensure numeric fields use consistent digit widths */
    .cc-metric .kpi,
    .cc-fact .value,
    .gauge .val,
    .edgecalc .net .value,
    .fileRow .meta,
    th, td{
      font-variant-numeric: tabular-nums lining-nums;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }
    .edgebar{
      height:34px;
      border-radius:999px;
      background: var(--panel2);
      border:1px solid var(--border);
      display:flex;
      overflow:hidden;
    }
    .edgebar .seg{
      display:flex;
      align-items:center;
      justify-content:center;
      color:#ffffff;
      font-size:13px;
      font-weight:800;
      padding:0 10px;
      white-space:nowrap;
      min-width:0;
    }
    .edgebar .seg span{overflow:hidden;text-overflow:ellipsis}
    .edgebar .spread{background: var(--bad)}
    .edgebar .fee{background: var(--warn)}
    .edgebar .netpos{background: var(--good)}
    .edgebar .netneg{background: rgba(107,114,128,.45)}
    .edgecalc .foot{
      display:flex;
      justify-content:space-between;
      gap:10px;
      font-size:14px;
      color:var(--muted);
      border-top:1px solid var(--border);
      padding-top:10px;
      margin-top:12px;
    }
    .edgecalc .foot strong{color:var(--text)}

    /* Lag/latency gauges */
    .gauges{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:10px}
    .gauge{
      display:flex;
      gap:12px;
      align-items:center;
      border:1px solid var(--border);
      background: var(--panel2);
      border-radius: 14px;
      padding:12px;
    }
    .ring{
      width:44px;height:44px;border-radius:999px;
      border:5px solid rgba(107,114,128,.35);
      flex:0 0 auto;
    }
    .ring.good{border-color: rgba(22,163,74,.85); background: rgba(22,163,74,.10)}
    .ring.bad{border-color: rgba(239,68,68,.85); background: rgba(239,68,68,.10)}
    .ring.warn{border-color: rgba(245,158,11,.85); background: rgba(245,158,11,.10)}
    .gauge .name{font-size:14px;color:var(--muted);margin:0}
    .gauge .val{font-size:22px;font-weight:900;margin:2px 0 0 0;color:var(--text)}
    .gauge .hint{font-size:13px;color:var(--muted);margin:0}

    /* Tables */
    .tablewrap{
      max-width:100%;
      overflow-x:auto;
      overflow-y:auto;
      -webkit-overflow-scrolling:touch;
      scrollbar-gutter: stable;
      cursor: grab;
      background: var(--panel);
      border-radius: var(--radius);
      box-shadow: var(--shadowSoft);
      padding: 8px;
      margin-top: 10px;
    }
    .tablewrap.dragging{cursor: grabbing}
    table{
      width:max-content;
      min-width:100%;
      border-collapse:separate;
      border-spacing:0;
      margin-top:0;
    }
    th,td{
      border-bottom:1px solid var(--border);
      padding:10px 10px;
      text-align:left;
      font-size:15px;
      white-space:nowrap;
    }
    th{
      color:var(--muted);
      font-weight:700;
      background: var(--panel2);
      position: sticky;
      top: 0;
      z-index: 1;
    }
    tbody tr:nth-child(even){background: rgba(17,24,39,.06)}
    tbody tr:hover{background: rgba(59,130,246,.08)}
    .muted{color:var(--muted)}
    .mono{font-family:var(--mono)}

    /* KPI / number styling (more like a trading dashboard)
       Many numeric values are rendered as "mono" in injected blocks; keep mono for code/filenames,
       but force KPI + numeric spans back to the UI font for the desired look. */
    .mono.kpi,
    .mono.num{
      font-family: var(--font);
    }
    .kpi{
      color: var(--accent);
      font-weight: 900;
      letter-spacing: -0.03em;
      font-variant-numeric: tabular-nums lining-nums;
      font-feature-settings: "tnum" 1, "lnum" 1;
    }
    .kpi.num.good{ color: var(--good); }
    .kpi.num.bad{ color: var(--bad); }
    .cc-equity{
      color: var(--accent);
      text-shadow: 0 0 22px color-mix(in srgb, var(--accent) 35%, transparent);
    }
    .num.good{color:var(--good)}
    .num.bad{color:var(--bad)}
    .num.warn{color:var(--warn)}

    /* Mobile */
    @media (max-width: 980px){
      .app{grid-template-columns: 1fr}
      .sidebar{position:relative;height:auto}
      .content{min-height:auto}
      .card{grid-column: span 12}
      .opsbar{grid-template-columns:1fr}
      .opsright{border-left:0;padding-left:0;border-top:1px solid var(--border);padding-top:12px}
    }
  </style>
</head>

<body>
  <div class="app">
    <aside class="sidebar">
      <div class="brand">
        <div class="logo">S</div>
        <div>
          <h1>spelar.eu</h1>
          <small id="buildInfo">Systematisk · tidsbegränsad edge · riskkontrollerad</small>
        </div>
      </div>

      <nav class="nav" id="nav"></nav>
    </aside>

    <main class="main">
      <div class="topbar">
        <div>
          <div class="crumbs" id="crumbs">Start</div>
          <h2 class="title" id="pageTitle">Översikt</h2>
        </div>
      </div>

      <section class="opsbar" id="opsBar" aria-live="polite" style="display:none">
        <div>
          <h3>Uppdateringskontroll</h3>
          <p><strong>Det du ser här bygger på snapshots.</strong> Om en fil är gammal betyder det att den inte har uppdaterats nyligen.</p>
          <p class="muted">Tips: klicka fil-länkarna för att se exakt innehåll.</p>
          <div class="liveSummary" id="opsSummary">Laddar status…</div>
        </div>
        <div class="opsright">
          <h3>Filer kopplade till sidan</h3>
          <p class="muted">Portalen använder dessa filer för den här vyn.</p>
          <div class="filelist" id="opsFiles"></div>
        </div>
      </section>

      <section class="content" id="content">
        Laddar…
      </section>
    </main>
  </div>

  <script>
    // ----------------------------
    // ROUTES / NAV STRUCTURE
    // ----------------------------
    const NAV = [
      {
        section: "Start",
        items: [
          { id:"start-home", label:"Startsida", route:"#/start", page:"start_home.html", badge:"", dataFiles:[] }
        ]
      },
      {
        section: "Strategi & Teknik",
        items: [
          { id:"strategy-about", label:"Om strategin", route:"#/strategy/about", page:"strategy_about.html", badge:"", dataFiles:[] },
          { id:"strategy-flow", label:"Hur systemet tänker", route:"#/strategy/flow", page:"strategy_flow.html", badge:"", dataFiles:[] },
          { id:"strategy-risk", label:"Risk & begränsningar", route:"#/strategy/risk", page:"strategy_risk.html", badge:"", dataFiles:[] },
          { id:"strategy-tech", label:"Teknisk översikt", route:"#/strategy/tech", page:"strategy_tech.html", badge:"", dataFiles:[] }
        ]
      },
      {
        section: "Engine Room",
        items: [
          { id:"transparency-data", label:"Engine Room", route:"#/data", page:"transparency_data.html", badge:"", showNotice:false, showOps:true,
            dataFiles:["live_status.json","polymarket_status.json","pm_paper_portfolio.json","pm_paper_positions.csv","pm_paper_trades.csv","edge_signals_live.csv","edge_calculator_live.csv","lead_lag_health.json","pm_paper_candidates.csv","pm_scan_candidates.csv","pm_markets_index.json"] }
        ]
      }
    ];

    const DEFAULT_ROUTE = "#/start";

    // ----------------------------
    // DOM refs
    // ----------------------------
    const navEl = document.getElementById("nav");
    const contentEl = document.getElementById("content");
    const crumbsEl = document.getElementById("crumbs");
    const titleEl = document.getElementById("pageTitle");
    const opsSummaryEl = document.getElementById("opsSummary");
    const opsFilesEl = document.getElementById("opsFiles");
    const opsBarEl = document.getElementById("opsBar");

    // ----------------------------
    // Build sidebar
    // ----------------------------
    function buildNav(){
      navEl.innerHTML = "";

      for (const sec of NAV){

        const wrap = document.createElement("div");
        wrap.className = "nav-section";

        const title = document.createElement("div");
        title.className = "sec-title";
        title.textContent = sec.section;
        wrap.appendChild(title);

        const itemsEl = document.createElement("div");
        itemsEl.className = "nav-items";

        for (const it of sec.items){
          const a = document.createElement("a");
          a.href = it.route;
          a.dataset.route = it.route;

          const left = document.createElement("span");
          left.textContent = it.label;
          a.appendChild(left);

          if (it.badge){
            const badge = document.createElement("span");
            badge.className = "badge";
            badge.textContent = it.badge;
            a.appendChild(badge);
          }
          itemsEl.appendChild(a);
        }

        wrap.appendChild(itemsEl);
        navEl.appendChild(wrap);
      }

      setActiveLink(location.hash || DEFAULT_ROUTE);
    }

    // ----------------------------
    // Router
    // ----------------------------
    function findRoute(hash){
      for (const sec of NAV){
        for (const it of sec.items){
          if (it.route === hash) return { section: sec.section, ...it };
        }
      }
      return null;
    }

    function setActiveLink(hash){
      document.querySelectorAll(".nav a").forEach(a => {
        a.classList.toggle("active", a.dataset.route === hash);
      });
    }

    async function loadPage(pageFile){
      const url = `./pages/${pageFile}`;
      const r = await fetch(url, { cache: "no-store" });
      if (!r.ok) throw new Error(`Kunde inte ladda ${url} (${r.status})`);
      return await r.text();
    }

    function withCacheBust(url){
      const sep = url.includes("?") ? "&" : "?";
      return `${url}${sep}_ts=${Date.now()}`;
    }

    function dataUrl(file){
      return withCacheBust(`./data/${encodeURIComponent(String(file || ""))}`);
    }

    function fileStatusKind(ageMs, ok){
      if (!ok) return "bad";
      if (!Number.isFinite(ageMs)) return "warn";
      if (ageMs <= 5*60*1000) return "ok";
      if (ageMs <= 30*60*1000) return "warn";
      return "bad";
    }

    function renderOpsFiles(files, results){
      if (!files || files.length === 0) {
        return `<p class="muted">Den här sidan har inga kopplade datafiler.</p>`;
      }

      const byName = new Map((results || []).map(r => [r.file, r]));
      const now = Date.now();

      return files.map(file => {
        const r = byName.get(file);
        const ok = !!(r && r.ok);
        const ageMs = (ok && Number.isFinite(r.lastModified)) ? Math.max(0, now - r.lastModified) : NaN;
        const age = ok ? (Number.isFinite(ageMs) ? formatAge(ageMs) : "? (saknar Last-Modified)") : "saknas/ej läsbar";
        const kind = fileStatusKind(ageMs, ok);
        const statusLabel = !ok ? "Error" : (kind === "ok" ? "Live" : "Väntar");

        const sizeText = (ok && Number.isFinite(r.sizeBytes)) ? formatBytes(r.sizeBytes) : "";
        const meta = [age, sizeText].filter(Boolean).join(" · ");

        const href = `./data/${encodeURIComponent(file)}`;
        const titleParts = [];
        if (ok && Number.isFinite(r.lastModified)) titleParts.push(`Last-Modified: ${formatUtcTimestamp(r.lastModified)}`);
        if (ok && Number.isFinite(r.sizeBytes)) titleParts.push(`Size: ${formatBytes(r.sizeBytes)}`);
        titleParts.push(`Status: ${statusLabel}`);
        const title = titleParts.join("\n");
        return `
          <div class="fileRow">
            <div class="left">
              <span class="dot ${kind}"></span>
              <span class="statusBadge ${kind}">${escapeHtml(statusLabel)}</span>
              <a class="name" href="${href}" target="_blank" rel="noopener">${escapeHtml(file)}</a>
            </div>
            <div class="meta" title="${escapeHtml(title)}">${escapeHtml(meta)}</div>
          </div>
        `;
      }).join("");
    }

    function renderNotice(route){
      const files = (route && Array.isArray(route.dataFiles)) ? route.dataFiles : [];
      const list = files.length
        ? files.map(f => `<li class="mono"><a href="./data/${encodeURIComponent(f)}" target="_blank" rel="noopener">${escapeHtml(f)}</a></li>`).join("")
        : "";

      return `
        <div class="notice">
          <p><strong>Hur du verifierar att detta är uppdaterat:</strong> kontrollera att filerna under uppdateras (ålder sjunker) och att innehållet matchar det du förväntar dig.</p>
          ${files.length ? `<p class="muted" style="margin-top:8px">Den här sidan läser:</p><ul>${list}</ul>` : `<p class="muted">Den här sidan visar främst text/struktur och har inga kopplade datafiler.</p>`}
        </div>
      `;
    }

    function formatAge(ms){
      if (!Number.isFinite(ms) || ms < 0) return "?";
      const s = Math.floor(ms / 1000);
      if (s <= 0) return "just nu";
      if (s < 60) return `${s} sek sedan`;
      const m = Math.floor(s / 60);
      if (m < 60) return `${m} min sedan`;
      const h = Math.floor(m / 60);
      if (h < 24){
        const mm = m % 60;
        return mm ? `${h} h ${mm} min sedan` : `${h} h sedan`;
      }
      const d = Math.floor(h / 24);
      return d === 1 ? `1 dygn sedan` : `${d} dygn sedan`;
    }

    function formatBytes(bytes){
      if (!Number.isFinite(bytes) || bytes < 0) return "";
      if (bytes < 1024) return `${Math.round(bytes)} B`;
      const kb = bytes / 1024;
      if (kb < 1024) return `${kb.toFixed(1)} KB`;
      const mb = kb / 1024;
      return `${mb.toFixed(1)} MB`;
    }

    function parseTimestampMs(s){
      if (!s) return NaN;
      const t = Date.parse(String(s));
      return Number.isFinite(t) ? t : NaN;
    }

    function formatUtcTimestamp(ms){
      if (!Number.isFinite(ms)) return "?";
      try{
        return new Date(ms).toISOString().slice(0,19).replace("T"," ") + " UTC";
      }catch(_e){
        return "?";
      }
    }

    function renderBlockMetaLine(file, lastModifiedMs){
      const now = Date.now();
      const ageMs = Number.isFinite(lastModifiedMs) ? Math.max(0, now - lastModifiedMs) : NaN;
      const age = Number.isFinite(ageMs) ? formatAge(ageMs) : "?";
      const ts = formatUtcTimestamp(lastModifiedMs);
      return `<p class="muted" style="margin:8px 0 0 0">Fil: <span class="mono">${escapeHtml(String(file || ""))}</span> · Senast uppdaterad: <span class="mono">${escapeHtml(age)}</span> <span class="muted mono">(${escapeHtml(ts)})</span></p>`;
    }

    async function getLastModifiedForDataFile(file){
      const url = dataUrl(file);
      // Prefer HEAD (fast). Fallback to GET if HEAD is blocked.
      try{
        const r = await fetch(url, { method: "HEAD", cache: "no-store" });
        if (r.ok){
          const lm = r.headers.get("Last-Modified");
          const cl = r.headers.get("Content-Length");
          const sizeBytes = cl ? Number(cl) : NaN;
          if (lm) return { ok:true, file, lastModified: new Date(lm).getTime(), sizeBytes };
          // Some servers omit Last-Modified; treat as unknown.
          return { ok:true, file, lastModified: NaN, sizeBytes };
        }
      }catch(_e){ /* ignore */ }

      try{
        const r2 = await fetch(url, { cache: "no-store" });
        if (!r2.ok) return { ok:false, file, lastModified: NaN, sizeBytes: NaN };
        const lm2 = r2.headers.get("Last-Modified");
        const cl2 = r2.headers.get("Content-Length");
        const sizeBytes2 = cl2 ? Number(cl2) : NaN;
        return { ok:true, file, lastModified: lm2 ? new Date(lm2).getTime() : NaN, sizeBytes: sizeBytes2 };
      }catch(_e2){
        return { ok:false, file, lastModified: NaN, sizeBytes: NaN };
      }
    }

    async function updateLiveStatusForRoute(route){
      const files = (route && Array.isArray(route.dataFiles)) ? route.dataFiles : [];
      if (files.length === 0){
        opsSummaryEl.textContent = "Den här sidan har inga datafiler kopplade.";
        opsFilesEl.innerHTML = renderOpsFiles(files, []);
        return;
      }

      const results = await Promise.all(files.map(getLastModifiedForDataFile));
      const ok = results.some(r => r.ok);
      if (!ok){
        opsSummaryEl.textContent = "Kunde inte läsa någon av sidans datafiler. Kontrollera att filerna finns uppladdade.";
        opsFilesEl.innerHTML = renderOpsFiles(files, results);
        return;
      }

      // Choose the newest known timestamp.
      const now = Date.now();
      let best = null;
      for (const r of results){
        if (!r.ok) continue;
        if (!Number.isFinite(r.lastModified)) continue;
        if (!best || r.lastModified > best.lastModified) best = r;
      }

      if (!best){
        // No Last-Modified available; still allow verification via direct file links.
        opsSummaryEl.innerHTML = `Data går att hämta, men servern skickar ingen <span class="mono">Last-Modified</span>. Klicka filerna för att verifiera innehåll.`;
        opsFilesEl.innerHTML = renderOpsFiles(files, results);
        return;
      }

      const ageMs = Math.max(0, now - best.lastModified);
      const age = formatAge(ageMs);

      opsSummaryEl.innerHTML = `Nyast uppdaterad fil: <span class="mono">${escapeHtml(best.file)}</span> · ålder <span class="mono">${escapeHtml(age)}</span>.`;
      opsFilesEl.innerHTML = renderOpsFiles(files, results);
    }

    async function render(){
      const hash = location.hash || DEFAULT_ROUTE;
      const route = findRoute(hash) || findRoute(DEFAULT_ROUTE);

      if (!route){
        location.hash = DEFAULT_ROUTE;
        return;
      }

      setActiveLink(route.route);

      crumbsEl.textContent = `${route.section}`;
      titleEl.textContent = route.label;

      const showOps = !!route.showOps;
      opsBarEl.style.display = showOps ? "" : "none";

      stopAutoRefresh();

      try{
        const html = await loadPage(route.page);
        contentEl.innerHTML = (route.showNotice ? renderNotice(route) : "") + html;

        // Render CSV/JSON blocks placed inside pages
        await hydrateDataBlocks();

        if (showOps){
          await updateLiveStatusForRoute(route);
        }

        startAutoRefresh(route);
      }catch(e){
        contentEl.innerHTML = `
          <h2>Kunde inte ladda sidan</h2>
          <p class="muted mono">${escapeHtml(String(e))}</p>
          <p>Kontrollera att filen finns i <span class="mono">/web/pages/</span>.</p>
        `;

        stopAutoRefresh();
      }
    }

    // ----------------------------
    // Auto-refresh (keeps boxes updating without manual reload)
    // ----------------------------
    const AUTO_REFRESH_MS = 20_000;
    let autoRefreshTimer = null;
    let autoRefreshInFlight = false;

    function stopAutoRefresh(){
      if (autoRefreshTimer){
        clearInterval(autoRefreshTimer);
        autoRefreshTimer = null;
      }
    }

    function shouldAutoRefresh(route){
      if (!route) return false;
      if (route.showOps) return true;
      if (Array.isArray(route.dataFiles) && route.dataFiles.length) return true;
      return !!contentEl.querySelector(
        "[data-command-center],[data-csv],[data-json],[data-paper-portfolio],[data-live-status],[data-edge-calculator],[data-lag-latency],[data-missed-opps]"
      );
    }

    async function refreshNow(route){
      if (autoRefreshInFlight) return;
      autoRefreshInFlight = true;
      try{
        await hydrateDataBlocks();
        if (route && route.showOps){
          await updateLiveStatusForRoute(route);
        }
      }catch(_e){
        // Keep UI responsive even if refresh fails.
      }finally{
        autoRefreshInFlight = false;
      }
    }

    function startAutoRefresh(route){
      stopAutoRefresh();
      if (!shouldAutoRefresh(route)) return;
      autoRefreshTimer = setInterval(() => { refreshNow(route); }, AUTO_REFRESH_MS);
    }

    // ----------------------------
    // CSV/JSON helpers (for /web/data/)
    // ----------------------------
    function escapeHtml(s){
      return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function parseCsv(text){
      // Minimal CSV parser (handles commas, quotes).
      const rows = [];
      let i = 0, field = "", row = [], inQuotes = false;

      while (i < text.length){
        const c = text[i];

        if (inQuotes){
          if (c === '"'){
            if (text[i+1] === '"'){ field += '"'; i += 2; continue; }
            inQuotes = false; i++; continue;
          }
          field += c; i++; continue;
        }else{
          if (c === '"'){ inQuotes = true; i++; continue; }
          if (c === ","){ row.push(field); field=""; i++; continue; }
          if (c === "\n"){
            row.push(field); field="";
            if (row.length > 1 || row[0] !== "") rows.push(row);
            row = []; i++; continue;
          }
          if (c === "\r"){ i++; continue; }
          field += c; i++; continue;
        }
      }
      row.push(field);
      if (row.length > 1 || row[0] !== "") rows.push(row);
      return rows;
    }

    function tryParseNumber(s){
      if (typeof s === "number") return s;
      if (s === null || s === undefined) return NaN;
      const t = String(s).trim();
      if (!t) return NaN;
      const cleaned = t.endsWith("%") ? t.slice(0, -1) : t;
      const n = Number(cleaned);
      return Number.isFinite(n) ? n : NaN;
    }

    function numClass(n){
      if (!Number.isFinite(n)) return "";
      if (n > 0) return "num good";
      if (n < 0) return "num bad";
      return "num";
    }

    function humanizeReason(reason){
      const r = String(reason || "").trim();
      if (!r) return "";
      const map = {
        // strategy / edge_calculator_live.csv
        // NOTE: some keys are legacy; keep aliases for older files.
        "spot_move_too_small": "Trend för liten",
        "trend_move_too_small": "Trend för liten",
        "low_edge": "Edge för låg",
        "net_edge_too_low": "Net edge för låg",
        "spread_too_high": "Spread för hög",
        "insufficient_liquidity": "För låg likviditet",
        "throttled": "Throttlad",
        "lag_too_short": "Lag för kort",
        "warmup": "Warmup",
        "stale_or_warmup": "Stale/Warmup",
        "avoid_price_zone": "Price filtered",
        "avoid_price_zone_executable": "Price filtered (executable)",
        "other_side_open": "Other side already open",
        "not_best_side": "Not best side",
        "no_best_side": "No best side",
        "hold": "Holding",
        "enter": "Entered",
        "trend_gone": "Exit (trend gone)",
        "edge_exit": "Exit (edge faded)",
        "max_hold": "Exit (max hold)",
        "stop": "Exit (stop)",

        // pm_draw
        "draw_edge_too_small": "Draw-edge för liten",
        "draw_too_expensive": "Draw för dyr",
      };
      return map[r] || r;
    }

    function renderTableFromRows(rows, maxRows=200){
      if (!rows || rows.length === 0) return `<p class="muted">Ingen data.</p>`;
      const head = rows[0];
      const body = rows.slice(1, maxRows + 1);

      const headLower = head.map(h => String(h || "").toLowerCase());
      const shouldColor = (hl) => hl.includes("pnl") || hl.includes("edge") || hl.includes("return") || hl.includes("roi");

      const th = head.map(h => `<th>${escapeHtml(h)}</th>`).join("");
      const tr = body.map(r => {
        const tds = head.map((_, idx) => {
          const v = r[idx] ?? "";
          const hl = headLower[idx] || "";
          let cls = "mono";
          if (shouldColor(hl)){
            const n = tryParseNumber(v);
            const nc = numClass(n);
            if (nc) cls += " " + nc;
          }
          return `<td class="${cls}">${escapeHtml(String(v))}</td>`;
        }).join("");
        return `<tr>${tds}</tr>`;
      }).join("");

      const note = rows.length - 1 > maxRows
        ? `<p class="muted">Visar ${maxRows} av ${rows.length - 1} rader.</p>` : "";

      return `
        ${note}
        <div class="tablewrap">
          <table>
            <thead><tr>${th}</tr></thead>
            <tbody>${tr}</tbody>
          </table>
        </div>
      `;
    }

    async function hydrateDataBlocks(){
      // Shared numeric formatting helpers used by multiple blocks.
      const fmt2 = (n) => Number.isFinite(n) ? n.toFixed(2) : "";

      // Command Center (headline view)
      const ccBlocks = Array.from(contentEl.querySelectorAll("[data-command-center]"));
      for (const el of ccBlocks){
        const portfolioFile = el.getAttribute("data-portfolio") || "pm_paper_portfolio.json";
        const liveFile = el.getAttribute("data-live") || "live_status.json";
        const tradesFile = el.getAttribute("data-trades") || "pm_paper_trades.csv";
        const edgeFile = el.getAttribute("data-edge") || "edge_calculator_live.csv";
        const positionsFile = el.getAttribute("data-positions") || "pm_paper_positions.csv";
        const scanCandidatesFile = el.getAttribute("data-scan-candidates") || "pm_scan_candidates.csv";
        const marketsIndexFile = el.getAttribute("data-markets-index") || "pm_markets_index.json";
        const sourcesFile = el.getAttribute("data-sources") || "";
        const feedMax = parseInt(el.getAttribute("data-feed-max") || "8", 10);

        try{
          const [rPort, rLive, rTrades, rPos, rEdge] = await Promise.all([
            fetch(dataUrl(portfolioFile), { cache: "no-store" }),
            fetch(dataUrl(liveFile), { cache: "no-store" }),
            fetch(dataUrl(tradesFile), { cache: "no-store" }),
            fetch(dataUrl(positionsFile), { cache: "no-store" }),
            fetch(dataUrl(edgeFile), { cache: "no-store" }),
          ]);

          if (!rPort.ok) throw new Error(`${portfolioFile} (${rPort.status})`);
          if (!rLive.ok) throw new Error(`${liveFile} (${rLive.status})`);
          if (!rTrades.ok) throw new Error(`${tradesFile} (${rTrades.status})`);
          if (!rPos.ok) throw new Error(`${positionsFile} (${rPos.status})`);
          if (!rEdge.ok) throw new Error(`${edgeFile} (${rEdge.status})`);

          const portfolio = await rPort.json();
          const live = await rLive.json();
          const tradesText = await rTrades.text();
          const posText = await rPos.text();
          const edgeText = await rEdge.text();

          // Optional: scan discovery (used to show what we're searching for / found)
          let scanText = "";
          try{
            const rScan = await fetch(dataUrl(scanCandidatesFile), { cache: "no-store" });
            if (rScan.ok) scanText = await rScan.text();
          }catch{
            scanText = "";
          }

          // Optional: markets index (not strictly required to render CC)
          let marketsIndex = null;
          try{
            const rIdx = await fetch(dataUrl(marketsIndexFile), { cache: "no-store" });
            if (rIdx.ok) marketsIndex = await rIdx.json();
          }catch{
            marketsIndex = null;
          }

          let sources = null;
          if (sourcesFile){
            try{
              const rSrc = await fetch(dataUrl(sourcesFile), { cache: "no-store" });
              if (rSrc.ok) sources = await rSrc.json();
            }catch{
              sources = null;
            }
          }

          const equity = Number(portfolio?.equity_usd ?? NaN);
          const startBal = Number(portfolio?.start_balance_usd ?? NaN);
          const cash = Number(portfolio?.cash_usd ?? NaN);
          const rpnl = Number(portfolio?.realized_pnl_usd ?? 0);
          const upnl = Number(portfolio?.unrealized_pnl_usd ?? 0);
          const openPos = Number(portfolio?.open_positions ?? NaN);
          const pnlSinceStart = (Number.isFinite(equity) && Number.isFinite(startBal)) ? (equity - startBal) : NaN;

          const liveTs = String(live?.ts ?? "");
          const liveMs = parseTimestampMs(liveTs);
          const liveAgeMs = Number.isFinite(liveMs) ? Math.max(0, Date.now() - liveMs) : NaN;

          let statusCls = "warn";
          let statusText = "SYSTEM";
          if (Number.isFinite(liveAgeMs)){
            if (liveAgeMs <= 60_000) { statusCls = "ok"; statusText = "SYSTEM ONLINE"; }
            else if (liveAgeMs <= 5 * 60_000) { statusCls = "warn"; statusText = "SYSTEM LIVE (SLOW)"; }
            else { statusCls = "bad"; statusText = "SYSTEM STALE"; }
          }

          const tradingMode = String(live?.trading_mode ?? "paper").toUpperCase();
          const strategyMode = String(live?.strategy_mode ?? live?.mode ?? "-");
          const mapped = Number(live?.mapped_markets ?? NaN);
          const marketLagMs = tryParseNumber(live?.market_lag_ms);
          const systemLatencyMs = tryParseNumber(live?.system_latency_ms);
          const killswitch = (live?.killswitch ?? live?.kill_switch);

          // Scan settings (best-effort; makes intent visible)
          const scanEnabled = (live?.pm_scan_enable ?? live?.scan_enable);
          const scanSearch = String(live?.pm_scan_search ?? live?.scan_search ?? "").trim();
          const scanOrder = String(live?.pm_scan_order ?? live?.scan_order ?? "").trim();
          const scanDirection = String(live?.pm_scan_direction ?? live?.scan_direction ?? "").trim();
          const scanBinaryOnly = (live?.pm_scan_binary_only ?? live?.scan_binary_only);

          // pm_draw settings (best-effort; makes targets visible)
          const drawEdgeMin = tryParseNumber(live?.pm_draw_edge_min_pct);
          const drawEdgeExit = tryParseNumber(live?.pm_draw_edge_exit_pct);
          const drawMaxPrice = tryParseNumber(live?.pm_draw_max_price);
          const drawRequire3way = live?.pm_draw_require_3way;
          const drawFavMin = tryParseNumber(live?.pm_draw_fav_min);
          const drawFavMax = tryParseNumber(live?.pm_draw_fav_max);
          const drawBaselineFile = String(live?.pm_draw_baseline_file ?? "").trim();

          // Positions summary
          const posRows = parseCsv(posText);
          const posCount = Math.max(0, posRows.length - 1);
          let posUpnl = 0;
          let posValue = 0;
          let posAdds = 0;
          let topPos = null; // { market, outcome, value, pnl }
          let openPositionsTooltip = "Inga öppna positioner.";
          if (posRows.length > 1){
            const head = posRows[0].map(h => String(h || "").toLowerCase());
            const idxPnl = head.indexOf("unrealized_pnl");
            const idxValue = head.indexOf("value");
            const idxMarket = head.indexOf("market");
            const idxOutcome = head.indexOf("outcome");
            const idxShares = head.indexOf("shares");
            const idxAvg = head.indexOf("avg_entry");
            const idxLast = head.indexOf("last_price");
            const idxAdds = head.indexOf("adds");
            const idxLastMid = head.indexOf("last_mid");
            const idxLastScaleAt = head.indexOf("last_scale_at");
            if (idxPnl >= 0){
              for (const r of posRows.slice(1)){
                const n = tryParseNumber(r[idxPnl]);
                if (Number.isFinite(n)) posUpnl += n;
              }
            }
            if (idxValue >= 0){
              for (const r of posRows.slice(1)){
                const v = tryParseNumber(r[idxValue]);
                if (Number.isFinite(v)) posValue += v;

                if (idxAdds >= 0){
                  const a = tryParseNumber(r[idxAdds]);
                  if (Number.isFinite(a)) posAdds += a;
                }

                if (Number.isFinite(v) && (!topPos || v > topPos.value)){
                  const m = idxMarket >= 0 ? String(r[idxMarket] ?? "") : "";
                  const o = idxOutcome >= 0 ? String(r[idxOutcome] ?? "") : "";
                  const p = idxPnl >= 0 ? tryParseNumber(r[idxPnl]) : NaN;
                  topPos = { market: m, outcome: o, value: v, pnl: p };
                }
              }
            }

            // Tooltip list (keep it short)
            const items = [];
            for (const r of posRows.slice(1)){
              const m = idxMarket >= 0 ? String(r[idxMarket] ?? "") : "";
              const o = idxOutcome >= 0 ? String(r[idxOutcome] ?? "") : "";
              const sh = idxShares >= 0 ? tryParseNumber(r[idxShares]) : NaN;
              const avg = idxAvg >= 0 ? tryParseNumber(r[idxAvg]) : NaN;
              const last = idxLast >= 0 ? tryParseNumber(r[idxLast]) : NaN;
              const adds = idxAdds >= 0 ? tryParseNumber(r[idxAdds]) : NaN;
              const lastMid = idxLastMid >= 0 ? tryParseNumber(r[idxLastMid]) : NaN;
              const lastScaleAt = idxLastScaleAt >= 0 ? String(r[idxLastScaleAt] ?? "") : "";

              let line = m || "(okänd market)";
              if (o) line += ` (${o})`;
              const parts = [];
              if (Number.isFinite(sh)) parts.push(`${fmt2(sh)} sh`);
              if (Number.isFinite(avg)) parts.push(`avg $${fmt2(avg)}`);
              if (Number.isFinite(last)) parts.push(`last $${fmt2(last)}`);
              if (Number.isFinite(lastMid)) parts.push(`mid $${fmt2(lastMid)}`);
              if (Number.isFinite(adds) && adds > 0) parts.push(`scale +${Math.round(adds)}`);
              if (lastScaleAt) parts.push(`senast scale ${lastScaleAt}`);
              if (parts.length) line += ` — ${parts.join(" · ")}`;
              items.push(line);
            }

            const maxLines = 8;
            const shown = items.slice(0, maxLines);
            const rest = Math.max(0, items.length - shown.length);
            openPositionsTooltip = `Öppna positioner (${items.length}):\n` + shown.join("\n") + (rest ? `\n… +${rest} till` : "");
          }

          // Trades feed
          const tradeRows = parseCsv(tradesText);
          const tradeHead = tradeRows[0] || [];
          const tradeBody = tradeRows.slice(1);
          const h = tradeHead.map(x => String(x || "").toLowerCase());
          const col = (name) => h.indexOf(name);
          const iTs = col("ts");
          const iMarket = col("market");
          const iOutcome = col("outcome");
          const iAction = col("action");
          const iPrice = col("price");
          const iShares = col("shares");
          const iNotional = col("notional");
          const iStatus = col("status");
          const iNotes = col("notes");

          const latestTrades = tradeBody.slice(-feedMax).reverse();
          const latestTradeTs = (latestTrades.length && iTs >= 0) ? String(latestTrades[0][iTs] ?? "") : "";
          const latestTradeMs = parseTimestampMs(latestTradeTs);
          const latestTradeAgeMs = Number.isFinite(latestTradeMs) ? Math.max(0, Date.now() - latestTradeMs) : NaN;
          const eventsHtml = latestTrades.map(r => {
            const ts = iTs >= 0 ? String(r[iTs] ?? "") : "";
            const ms = parseTimestampMs(ts);
            const when = Number.isFinite(ms) ? formatAge(Math.max(0, Date.now() - ms)) : "–";

            const action = iAction >= 0 ? String(r[iAction] ?? "") : "";
            const market = iMarket >= 0 ? String(r[iMarket] ?? "") : "";
            const outcome = iOutcome >= 0 ? String(r[iOutcome] ?? "") : "";
            const price = iPrice >= 0 ? tryParseNumber(r[iPrice]) : NaN;
            const shares = iShares >= 0 ? tryParseNumber(r[iShares]) : NaN;
            const notional = iNotional >= 0 ? tryParseNumber(r[iNotional]) : NaN;
            const status = iStatus >= 0 ? String(r[iStatus] ?? "") : "";
            const notes = iNotes >= 0 ? String(r[iNotes] ?? "") : "";

            const isScale = /\bscale_in\b/i.test(notes);

            const verb = action === "BUY" ? (isScale ? "Skalade in" : "Köpte") : (action === "SELL" ? "Sålde" : (action ? action : "Trade"));
            const title = `${verb} ${market}${outcome ? (" (" + outcome + ")") : ""}`;
            const metaParts = [];
            if (Number.isFinite(price)) metaParts.push(`@$${fmt2(price)}`);
            if (Number.isFinite(shares)) metaParts.push(`${fmt2(shares)} shares`);
            if (Number.isFinite(notional)) metaParts.push(`$${fmt2(notional)}`);
            if (notes) metaParts.push(notes);
            const meta = metaParts.join(" · ");

            const pillCls = status === "filled" ? "pill" : (status === "skipped" ? "pill" : "pill");
            return `
              <div class="cc-event">
                <div class="left">
                  <p class="title">${escapeHtml(title)}</p>
                  <p class="meta">${escapeHtml(meta || "–")}</p>
                </div>
                <div class="right">
                  <span class="${pillCls}">${escapeHtml(isScale ? "SCALE" : (status || ""))}</span>
                  <span class="when">${escapeHtml(when)}</span>
                </div>
              </div>
            `;
          }).join("");

          // Fallback activity (when no trades): show last decision rows from edge_calculator_live.csv
          let edgeEventsHtml = "";
          try{
            const edgeRows = parseCsv(edgeText);
            const edgeHead = edgeRows[0] || [];
            const edgeBody = edgeRows.slice(1);
            const eh = edgeHead.map(x => String(x || "").toLowerCase());
            const ecol = (name) => eh.indexOf(name);
            const eTs = ecol("ts");
            const eMarket = ecol("market");
            const eStatus = ecol("execution_status");
            const eReason = ecol("reason");
            const eRaw = ecol("raw_edge");
            const eSpread = ecol("spread_cost");
            const eFees = ecol("fees");
            const eNet = ecol("net_edge");

            const latestEdges = edgeBody.slice(-feedMax).reverse();
            edgeEventsHtml = latestEdges.map(r => {
              const ts = eTs >= 0 ? String(r[eTs] ?? "") : "";
              const ms = parseTimestampMs(ts);
              const when = Number.isFinite(ms) ? formatAge(Math.max(0, Date.now() - ms)) : "–";

              const market = eMarket >= 0 ? String(r[eMarket] ?? "") : "";
              const status = eStatus >= 0 ? String(r[eStatus] ?? "") : "";
              const reason = eReason >= 0 ? String(r[eReason] ?? "") : "";
              const rawEdge = eRaw >= 0 ? tryParseNumber(r[eRaw]) : NaN;
              const spreadCost = eSpread >= 0 ? tryParseNumber(r[eSpread]) : NaN;
              const fees = eFees >= 0 ? tryParseNumber(r[eFees]) : NaN;
              const netEdge = eNet >= 0 ? tryParseNumber(r[eNet]) : NaN;

              const reasonTxt = humanizeReason(reason);
              const title = status && status.toUpperCase() === "SKIPPED"
                ? `Avstod: ${reasonTxt || "(orsak okänd)"}`
                : (status ? status : "Decision");

              const metaParts = [];
              if (market) metaParts.push(market);
              if (Number.isFinite(netEdge)) metaParts.push(`net ${fmt2(netEdge)}%`);
              if (Number.isFinite(rawEdge)) metaParts.push(`raw ${fmt2(rawEdge)}%`);
              if (Number.isFinite(spreadCost)) metaParts.push(`spread ${fmt2(spreadCost)}%`);
              if (Number.isFinite(fees)) metaParts.push(`fees ${fmt2(fees)}%`);
              const meta = metaParts.join(" · ");

              return `
                <div class="cc-event">
                  <div class="left">
                    <p class="title">${escapeHtml(title)}</p>
                    <p class="meta">${escapeHtml(meta || "–")}</p>
                  </div>
                  <div class="right">
                    <span class="pill">${escapeHtml(status || "")}</span>
                    <span class="when">${escapeHtml(when)}</span>
                  </div>
                </div>
              `;
            }).join("");
          }catch{
            edgeEventsHtml = "";
          }

          const equityStr = Number.isFinite(equity) ? `$${fmt2(equity)}` : "$–";
          const pnlCls = numClass(pnlSinceStart);
          const pnlArrow = Number.isFinite(pnlSinceStart) ? (pnlSinceStart >= 0 ? "▲" : "▼") : "";
          const pnlStr = Number.isFinite(pnlSinceStart) ? `${pnlArrow} $${fmt2(Math.abs(pnlSinceStart))} (sedan start)` : "–";

          const lagStr = Number.isFinite(marketLagMs)
            ? (marketLagMs >= 10_000 ? `${Math.round(marketLagMs/1000)}s` : `${Math.round(marketLagMs)}ms`)
            : "–";
          const latencyStr = Number.isFinite(systemLatencyMs) ? `${Math.round(systemLatencyMs)}ms` : "–";
          const exposureStr = Number.isFinite(posValue) && posValue > 0 ? `$${fmt2(posValue)}` : "–";
          const mappedStr = Number.isFinite(mapped) ? String(Math.round(mapped)) : "–";

          // Scan candidates summary (best-effort)
          let scanCount = NaN;
          let scanDrawCount = NaN;
          let scanLatestAgeMs = NaN;
          let scanLatestTs = "";
          let scanDrawListHtml = "";
          try{
            if (scanText && String(scanText).trim()){
              const scanRows = parseCsv(scanText);
              const scanHead = (scanRows[0] || []).map(h => String(h || "").toLowerCase());
              const scanBody = scanRows.slice(1);
              scanCount = Math.max(0, scanBody.length);

              const sCol = (name) => scanHead.indexOf(name);
              const sTs = sCol("ts");
              const sQ = sCol("question");
              const sOut = sCol("outcomes");
              const sEnd = sCol("end_date");

              const isDrawRow = (r) => {
                const out = sOut >= 0 ? String(r[sOut] ?? "") : "";
                const q = sQ >= 0 ? String(r[sQ] ?? "") : "";
                return /\bdraw\b/i.test(out) || /\bdraw\b/i.test(q);
              };

              const drawRows = scanBody.filter(isDrawRow);
              scanDrawCount = drawRows.length;

              if (scanBody.length && sTs >= 0){
                scanLatestTs = String(scanBody[0][sTs] ?? "");
                const ms = parseTimestampMs(scanLatestTs);
                scanLatestAgeMs = Number.isFinite(ms) ? Math.max(0, Date.now() - ms) : NaN;
              }

              const shown = drawRows.slice(0, 6);
              scanDrawListHtml = shown.length
                ? shown.map(r => {
                    const q = sQ >= 0 ? String(r[sQ] ?? "") : "";
                    const out = sOut >= 0 ? String(r[sOut] ?? "") : "";
                    const end = sEnd >= 0 ? String(r[sEnd] ?? "") : "";
                    const meta = [out, end].filter(Boolean).join(" · ");
                    return `
                      <div class="cc-event" style="margin:0">
                        <div class="left">
                          <p class="title">${escapeHtml(q || "(okänd market)")}</p>
                          <p class="meta">${escapeHtml(meta || "–")}</p>
                        </div>
                      </div>
                    `;
                  }).join("")
                : `<p class="muted" style="margin:0">Inga draw-kandidater i senaste scan.</p>`;
            }
          }catch{
            scanCount = NaN;
            scanDrawCount = NaN;
            scanLatestAgeMs = NaN;
            scanLatestTs = "";
            scanDrawListHtml = "";
          }

          const seekKpi = (String(strategyMode).toLowerCase() === "pm_draw") ? "Söker DRAW" : "Söker";
          const scanAgeStr = Number.isFinite(scanLatestAgeMs) ? formatAge(scanLatestAgeMs) : "–";
          const scanCountStr = Number.isFinite(scanCount) ? String(Math.round(scanCount)) : "–";
          const scanDrawCountStr = Number.isFinite(scanDrawCount) ? String(Math.round(scanDrawCount)) : "–";
          const scanEnabledStr = (scanEnabled === null || scanEnabled === undefined) ? "–" : (scanEnabled ? "ON" : "OFF");
          const scanBinaryStr = (scanBinaryOnly === null || scanBinaryOnly === undefined) ? "–" : (scanBinaryOnly ? "1" : "0");
          const drawEdgeMinStr = Number.isFinite(drawEdgeMin) ? `${fmt2(drawEdgeMin)}%` : "–";
          const drawMaxPriceStr = Number.isFinite(drawMaxPrice) ? `$${drawMaxPrice.toFixed(3)}` : "–";
          const drawFavStr = (Number.isFinite(drawFavMin) || Number.isFinite(drawFavMax))
            ? `${Number.isFinite(drawFavMin) ? drawFavMin.toFixed(2) : "–"}–${Number.isFinite(drawFavMax) ? drawFavMax.toFixed(2) : "–"}`
            : "–";

          const health = (() => {
            const pmClobOk = Boolean(sources?.polymarket?.clob?.ok);
            const pmGammaOk = Boolean(sources?.polymarket?.gamma?.ok);

            const pills = [];
            pills.push({
              key: "pm_clob",
              cls: pmClobOk ? "ok" : "bad",
              text: `Polymarket CLOB: ${pmClobOk ? "OK" : "FAIL"}`,
              tip: `Datakälla: ${sourcesFile || "sources_health.json"}\nTolkning: OK = lyckad senaste hämtning mot CLOB. FAIL = senaste försök misslyckades.`
            });
            pills.push({
              key: "pm_gamma",
              cls: pmGammaOk ? "ok" : "bad",
              text: `Gamma: ${pmGammaOk ? "OK" : "FAIL"}`,
              tip: `Datakälla: ${sourcesFile || "sources_health.json"}\nTolkning: OK = Gamma API svarar (market discovery). FAIL = problem att nå Gamma.`
            });
            return pills;
          })();

          el.classList.add("cc");
          el.innerHTML = `
            <div class="cc-shell">
              <div class="cc-hero">
                <div class="cc-status ${escapeHtml(statusCls)}">
                  <span class="cc-pulse" aria-hidden="true"></span>
                  <span>${escapeHtml(statusText)}</span>
                  <span class="mono">${escapeHtml(tradingMode)}</span>
                </div>
                <div class="cc-equity">${escapeHtml(equityStr)}</div>
                <div class="cc-sub"><span class="mono ${escapeHtml(pnlCls)}">${escapeHtml(pnlStr)}</span></div>
                <div class="cc-sub">Strategi: <span class="mono">${escapeHtml(strategyMode)}</span>${(killswitch === true || killswitch === false) ? ` · Killswitch: <span class=\"mono\">${escapeHtml(killswitch ? "PÅ" : "AV")}</span>` : ""}</div>
              </div>

              <div class="cc-metrics">
                <div class="cc-metric cc-openpos">
                  <h4>Öppna positioner</h4>
                  <div class="mono kpi">${escapeHtml(String(posCount))}</div>
                  <p class="cc-mini">Unrealized: <span class="mono ${escapeHtml(numClass(posUpnl))}">$${escapeHtml(fmt2(posUpnl))}</span>${posAdds > 0 ? ` · Skalningar: <span class="mono">+${escapeHtml(String(Math.round(posAdds)))}</span>` : ""}</p>
                </div>
                <div class="cc-metric cc-cash">
                  <h4>Cash</h4>
                  <div class="mono kpi">$${escapeHtml(fmt2(cash))}</div>
                  <p class="cc-mini">Realized: <span class="mono ${escapeHtml(numClass(rpnl))}">$${escapeHtml(fmt2(rpnl))}</span> · Unrealized: <span class="mono ${escapeHtml(numClass(upnl))}">$${escapeHtml(fmt2(upnl))}</span></p>
                </div>
                <div class="cc-metric cc-now">
                  <h4>Just nu</h4>
                  <div class="mono kpi">${escapeHtml(seekKpi)}</div>
                  <p class="cc-mini">Senast tick: <span class="mono">${escapeHtml(Number.isFinite(liveAgeMs) ? formatAge(liveAgeMs) : "–")}</span></p>
                </div>
              </div>

              <div class="cc-section">
                <h4>Vad vi söker (pm_draw)</h4>
                <p class="muted" style="margin:0">Vi letar efter matchmarknader där <strong>DRAW</strong> är billigare på Polymarket än vår baseline-probabilitet.</p>
                <div class="cc-facts" style="margin-top:10px">
                  <div class="cc-fact">
                    <div class="label">Scan</div>
                    <div class="value mono">${escapeHtml(scanEnabledStr)}</div>
                    <div class="sub">Binary-only: <span class="mono">${escapeHtml(scanBinaryStr)}</span></div>
                  </div>
                  <div class="cc-fact">
                    <div class="label">Sökord</div>
                    <div class="value mono">${escapeHtml(scanSearch || "–")}</div>
                    <div class="sub">${escapeHtml([scanOrder, scanDirection].filter(Boolean).join(" · ") || "–")}</div>
                  </div>
                  <div class="cc-fact">
                    <div class="label">Draw-gate</div>
                    <div class="value mono">${escapeHtml(drawEdgeMinStr)}</div>
                    <div class="sub">Max price: <span class="mono">${escapeHtml(drawMaxPriceStr)}</span></div>
                  </div>
                  <div class="cc-fact">
                    <div class="label">Fav-filter</div>
                    <div class="value mono">${escapeHtml(drawFavStr)}</div>
                    <div class="sub">Require 3-way: <span class="mono">${escapeHtml((drawRequire3way === null || drawRequire3way === undefined) ? "–" : String(drawRequire3way))}</span></div>
                  </div>
                  <div class="cc-fact wide">
                    <div class="label">Baseline</div>
                    <div class="value mono">${escapeHtml(drawBaselineFile || "(fallback)")}</div>
                    <div class="sub">(Fallback) p kommer från live_status.json om fil saknas</div>
                  </div>
                </div>
              </div>

              <div class="cc-section">
                <h4>Vad vi hittat (senaste scan)</h4>
                <p class="muted" style="margin:0">Källa: <span class="mono">${escapeHtml(scanCandidatesFile)}</span> · Senast: <span class="mono">${escapeHtml(scanAgeStr)}</span> · Kandidater: <span class="mono">${escapeHtml(scanCountStr)}</span> · Med Draw: <span class="mono">${escapeHtml(scanDrawCountStr)}</span></p>
                <div class="cc-feed" style="margin-top:10px">${scanDrawListHtml || `<p class="muted" style="margin:0">Ingen scan-data.</p>`}</div>
              </div>

              <div class="cc-section" style="margin-top:14px">
                <h4>Öppna positioner (live)</h4>
                <p class="muted" style="margin:0">Här ser du vilka positioner som faktiskt är öppna – och om de har börjat <strong>skala in</strong>.</p>
                <div class="cc-poslist">
                  ${(() => {
                    if (!posRows || posRows.length <= 1) return `<p class="muted" style="grid-column: span 12; margin:10px 0 0 0">Inga öppna positioner just nu.</p>`;
                    const head = posRows[0].map(h => String(h || "").toLowerCase());
                    const idxMarket = head.indexOf("market");
                    const idxOutcome = head.indexOf("outcome");
                    const idxShares = head.indexOf("shares");
                    const idxAvg = head.indexOf("avg_entry");
                    const idxUpnl = head.indexOf("unrealized_pnl");
                    const idxAdds = head.indexOf("adds");
                    const idxLastMid = head.indexOf("last_mid");
                    const idxLastScaleAt = head.indexOf("last_scale_at");

                    const items = posRows.slice(1).map(r => {
                      const market = idxMarket >= 0 ? String(r[idxMarket] ?? "") : "";
                      const outcome = idxOutcome >= 0 ? String(r[idxOutcome] ?? "") : "";
                      const shares = idxShares >= 0 ? tryParseNumber(r[idxShares]) : NaN;
                      const avg = idxAvg >= 0 ? tryParseNumber(r[idxAvg]) : NaN;
                      const upnl = idxUpnl >= 0 ? tryParseNumber(r[idxUpnl]) : NaN;
                      const adds = idxAdds >= 0 ? tryParseNumber(r[idxAdds]) : NaN;
                      const mid = idxLastMid >= 0 ? tryParseNumber(r[idxLastMid]) : NaN;
                      const lastScaleAt = idxLastScaleAt >= 0 ? String(r[idxLastScaleAt] ?? "").trim() : "";

                      const title = `${market || "(okänd market)"}${outcome ? (" (" + outcome + ")") : ""}`;
                      const metaParts = [];
                      if (Number.isFinite(shares)) metaParts.push(`${fmt2(shares)} sh`);
                      if (Number.isFinite(avg)) metaParts.push(`avg $${fmt2(avg)}`);
                      if (Number.isFinite(mid)) metaParts.push(`mid $${fmt2(mid)}`);
                      if (Number.isFinite(upnl)) metaParts.push(`uPnL $${fmt2(upnl)}`);
                      const meta = metaParts.join(" · ");

                      let scaleTag = "HOLD";
                      let scaleCls = "warn";
                      if (Number.isFinite(adds) && adds > 0){
                        scaleTag = `SCALE +${Math.round(adds)}`;
                        scaleCls = "good";
                      }

                      let lastScaleWhen = "–";
                      const lms = parseTimestampMs(lastScaleAt);
                      if (Number.isFinite(lms)) lastScaleWhen = formatAge(Math.max(0, Date.now() - lms));

                      return {
                        title,
                        meta,
                        upnl,
                        scaleTag,
                        scaleCls,
                        lastScaleWhen,
                        hasScale: (Number.isFinite(adds) && adds > 0) || Boolean(lastScaleAt),
                      };
                    });

                    // Sort: scaled positions first, then by abs uPnL desc.
                    items.sort((a, b) => {
                      const as = a.hasScale ? 1 : 0;
                      const bs = b.hasScale ? 1 : 0;
                      if (as !== bs) return bs - as;
                      const au = Number.isFinite(a.upnl) ? Math.abs(a.upnl) : -1;
                      const bu = Number.isFinite(b.upnl) ? Math.abs(b.upnl) : -1;
                      return bu - au;
                    });

                    const shown = items.slice(0, 6);
                    const rest = Math.max(0, items.length - shown.length);

                    const cards = shown.map(it => {
                      const pnlCls = numClass(it.upnl);
                      return `
                        <div class="cc-pos">
                          <div class="left">
                            <p class="title">${escapeHtml(it.title)}</p>
                            <p class="meta">${escapeHtml(it.meta || "–")}</p>
                          </div>
                          <div class="cc-tags">
                            <span class="cc-tag ${escapeHtml(it.scaleCls)}">${escapeHtml(it.scaleTag)}</span>
                            <span class="cc-tag ${escapeHtml(pnlCls === "good" ? "good" : (pnlCls === "bad" ? "bad" : "warn"))}">${escapeHtml(Number.isFinite(it.upnl) ? `PnL ${it.upnl >= 0 ? "+" : "-"}$${fmt2(Math.abs(it.upnl))}` : "PnL –")}</span>
                            <span class="cc-tag">${escapeHtml(it.hasScale ? `senast scale ${it.lastScaleWhen}` : "inte skalat än")}</span>
                          </div>
                        </div>
                      `;
                    }).join("");

                    return cards + (rest ? `<p class="muted" style="grid-column: span 12; margin:6px 0 0 0">… +${rest} fler positioner</p>` : "");
                  })()}
                </div>
              </div>

              <div class="cc-section">
                <h4>Snabba fakta</h4>
                <div class="cc-facts">
                  <div class="cc-fact cc-fact-mapped">
                    <div class="label">Kartlagda marknader</div>
                    <div class="value mono">${escapeHtml(mappedStr)}</div>
                    <div class="sub">Antal i market map</div>
                  </div>
                  <div class="cc-fact cc-fact-lag">
                    <div class="label">Market lag (om finns)</div>
                    <div class="value mono">${escapeHtml(lagStr)}</div>
                    <div class="sub">Kan vara N/A beroende på mode</div>
                  </div>
                  <div class="cc-fact cc-fact-latency">
                    <div class="label">System latency</div>
                    <div class="value mono">${escapeHtml(latencyStr)}</div>
                    <div class="sub">Internt loop-lag</div>
                  </div>
                  <div class="cc-fact cc-fact-exposure">
                    <div class="label">Exponering</div>
                    <div class="value mono">${escapeHtml(exposureStr)}</div>
                    <div class="sub">Summa position value</div>
                  </div>

                  <div class="cc-fact wide cc-fact-toppos">
                    <div class="label">Största position</div>
                    <div class="value">${escapeHtml(topPos ? (String(topPos.market) + (topPos.outcome ? (" (" + topPos.outcome + ")") : "")) : "–")}</div>
                    <div class="sub">Value: <span class="mono">${escapeHtml(topPos && Number.isFinite(topPos.value) ? `$${fmt2(topPos.value)}` : "–")}</span> · Unrealized: <span class="mono ${escapeHtml(numClass(topPos?.pnl))}">${escapeHtml(topPos && Number.isFinite(topPos.pnl) ? `$${fmt2(topPos.pnl)}` : "–")}</span></div>
                  </div>
                </div>

                ${health && health.length ? `<div class="cc-pills">${health.map(p => `<span class="cc-pill ${escapeHtml(p.cls)}" data-pill="${escapeHtml(p.key || "")}">${escapeHtml(p.text)}</span>`).join("")}</div>` : ""}
              </div>

              <h3 style="margin-top:18px">Action Feed</h3>
              <p class="muted">Senaste händelser (paper): trades + beslut att avstå.</p>
              <div class="cc-feed">${((latestTrades.length && (!Number.isFinite(latestTradeAgeMs) || latestTradeAgeMs <= 10 * 60_000)) ? eventsHtml : edgeEventsHtml) || "<p class=\"muted\">Inga events ännu.</p>"}</div>

              <p style="margin-top:16px">
                <a class="btn" href="#/data">Engine Room</a>
                <a class="btn" href="#/strategy/about">Så funkar strategin</a>
              </p>
            </div>
          `;

          // Attach tooltip to the whole metric card (works even when hovering children)
          const attachTip = (selector, tipText) => {
            const node = el.querySelector(selector);
            const text = String(tipText ?? "").trim();
            if (!node || !text) return;
            node.classList.add("hasTip");
            node.setAttribute("tabindex", "0");
            node.setAttribute("role", "note");
            node.dataset.tip = text;
          };

          const attachTipAll = (selector, tipText) => {
            const nodes = Array.from(el.querySelectorAll(selector));
            const text = String(tipText ?? "").trim();
            if (!nodes.length || !text) return;
            for (const node of nodes){
              node.classList.add("hasTip");
              node.setAttribute("tabindex", "0");
              node.setAttribute("role", "note");
              node.dataset.tip = text;
            }
          };

          attachTip(
            ".cc-openpos",
            `Vad betyder rutan?\nÖppna positioner = antal aktiva rader i ${positionsFile}.\nListan visar market/outcome + shares/avg/last (max 8 rader).\n\n${openPositionsTooltip}`
          );
          attachTip(
            ".cc-cash",
            `Vad betyder rutan?\nCash = fritt saldo i portföljen (USD).\nRealized/Unrealized = PnL för stängda/öppna positioner enligt ${portfolioFile}.`
          );
          attachTip(
            ".cc-now",
            `Vad betyder rutan?\nJust nu = vilket läge strategin är i.\n\"Senast tick\" visar hur gammal senaste ${liveFile}-uppdateringen är (grovt hälsotest).`
          );

          // Snabba fakta
          attachTip(
            ".cc-fact-mapped",
            `Kartlagda marknader\nKommer från ${liveFile}: fält mapped_markets.\nTolkning: hur många markets strategin har i sin market map.`
          );
          attachTip(
            ".cc-fact-lag",
            `Market lag\nKommer från ${liveFile}: fält market_lag_ms.\nTolkning: hur långt efter marknadsdata systemet ligger just nu.\nNot: kan saknas/N/A beroende på mode.`
          );
          
          attachTip(
            ".cc-fact-latency",
            `System latency\nKommer från ${liveFile}: fält system_latency_ms.\nTolkning: internt loop-/process-lag (inte samma som market lag).`
          );
          attachTip(
            ".cc-fact-exposure",
            `Exponering\nBeräknas från ${positionsFile}: summa av kolumnen value.\nTolkning: total position value (USD) för alla öppna positioner.`
          );
          attachTip(
            ".cc-fact-toppos",
            `Största position\nBeräknas från ${positionsFile}: raden med högst value.\nVisar market/outcome + dess value och unrealized_pnl.`
          );

          // Health pills (källa: sources_health.json)
          for (const pill of Array.from(el.querySelectorAll(".cc-pill[data-pill]"))){
            const k = String(pill.getAttribute("data-pill") || "");
            const item = (health || []).find(x => String(x.key || "") === k);
            if (!item || !String(item.tip || "").trim()) continue;
            pill.classList.add("hasTip");
            pill.setAttribute("tabindex", "0");
            pill.setAttribute("role", "note");
            pill.dataset.tip = String(item.tip);
          }

          // Action Feed
          attachTipAll(
            ".cc-feed .cc-event",
            `Action Feed\nKommer från ${tradesFile}: senaste ${feedMax} trades (senaste först).\nStatus (filled/skipped) och notes visar varför en trade blev/inte blev lagd.`
          );
        }catch(e){
          el.innerHTML = `<p class="muted">Kunde inte ladda Command Center: <span class="mono">${escapeHtml(String(e))}</span></p>`;
        }
      }

      const csvBlocks = Array.from(contentEl.querySelectorAll("[data-csv]"));
      for (const el of csvBlocks){
        const file = el.getAttribute("data-csv");
        const maxRows = parseInt(el.getAttribute("data-max-rows") || "200", 10);
        try{
          const r = await fetch(dataUrl(file), { cache: "no-store" });
          if (!r.ok) throw new Error(`${file} (${r.status})`);
          const lm = r.headers.get("Last-Modified");
          const lmMs = lm ? new Date(lm).getTime() : NaN;
          const text = await r.text();
          const rows = parseCsv(text);
          el.innerHTML = renderBlockMetaLine(file, lmMs) + renderTableFromRows(rows, maxRows);
        }catch(e){
          el.innerHTML = `<p class="muted">Kunde inte ladda CSV: <span class="mono">${escapeHtml(String(e))}</span></p>`;
        }
      }

      const jsonBlocks = Array.from(contentEl.querySelectorAll("[data-json]"));
      for (const el of jsonBlocks){
        const file = el.getAttribute("data-json");
        try{
          const r = await fetch(dataUrl(file), { cache: "no-store" });
          if (!r.ok) throw new Error(`${file} (${r.status})`);
          const lm = r.headers.get("Last-Modified");
          const lmMs = lm ? new Date(lm).getTime() : NaN;
          const obj = await r.json();
          el.innerHTML = renderBlockMetaLine(file, lmMs) + `<pre>${escapeHtml(JSON.stringify(obj, null, 2))}</pre>`;
        }catch(e){
          el.innerHTML = `<p class="muted">Kunde inte ladda JSON: <span class="mono">${escapeHtml(String(e))}</span></p>`;
        }
      }

      // Paper portfolio summary
      const paperBlocks = Array.from(contentEl.querySelectorAll("[data-paper-portfolio]"));
      for (const el of paperBlocks){
        const file = el.getAttribute("data-paper-portfolio");
        try{
          const r = await fetch(dataUrl(file), { cache: "no-store" });
          if (!r.ok) throw new Error(`${file} (${r.status})`);
          const lm = r.headers.get("Last-Modified");
          const lmMs = lm ? new Date(lm).getTime() : NaN;
          const obj = await r.json();

          const cash = Number(obj?.cash_usd ?? NaN);
          const equity = Number(obj?.equity_usd ?? NaN);
          const upnl = Number(obj?.unrealized_pnl_usd ?? 0);
          const rpnl = Number(obj?.realized_pnl_usd ?? 0);
          const openPos = Number(obj?.open_positions ?? 0);
          const ts = String(obj?.generated_at ?? "");
          const tsMs = parseTimestampMs(ts);
          const ageMs = Number.isFinite(tsMs)
            ? Math.max(0, Date.now() - tsMs)
            : (Number.isFinite(lmMs) ? Math.max(0, Date.now() - lmMs) : NaN);
          const rel = Number.isFinite(ageMs) ? formatAge(ageMs) : "–";
          const abs = ts || (Number.isFinite(lmMs) ? formatUtcTimestamp(lmMs) : "–");

          const rpnlCls = numClass(rpnl);
          const upnlCls = numClass(upnl);
          el.innerHTML = `
            ${renderBlockMetaLine(file, lmMs)}
            <div class="grid">
              <div class="card">
                <h4>Cash</h4>
                <div class="mono kpi">$${escapeHtml(fmt2(cash))}</div>
                <p class="muted">Open positions: <span class="mono">${escapeHtml(String(openPos))}</span></p>
              </div>
              <div class="card">
                <h4>Equity</h4>
                <div class="mono kpi">$${escapeHtml(fmt2(equity))}</div>
                <p class="muted">PnL: <span class="mono ${escapeHtml(rpnlCls)}">${escapeHtml(fmt2(rpnl))}</span> realized, <span class="mono ${escapeHtml(upnlCls)}">${escapeHtml(fmt2(upnl))}</span> unrealized</p>
              </div>
              <div class="card">
                <h4>Senast uppdaterad</h4>
                <p class="mono">${escapeHtml(rel)}</p>
                <p class="muted mono">${escapeHtml(abs)}</p>
                <p class="muted">Källa: <span class="mono">${escapeHtml(String(file))}</span></p>
              </div>
            </div>
          `;
        }catch(e){
          el.innerHTML = `<p class="muted">Kunde inte ladda paper-portfolio: <span class="mono">${escapeHtml(String(e))}</span></p>`;
        }
      }

      // Live status summary
      const liveBlocks = Array.from(contentEl.querySelectorAll("[data-live-status]"));
      for (const el of liveBlocks){
        const file = el.getAttribute("data-live-status");
        try{
          const r = await fetch(`./data/${file}`, { cache: "no-store" });
          if (!r.ok) throw new Error(`${file} (${r.status})`);
          const lm = r.headers.get("Last-Modified");
          const lmMs = lm ? new Date(lm).getTime() : NaN;
          const obj = await r.json();

          const tradingMode = String(obj?.trading_mode ?? "–");
          const strategyMode = String(obj?.strategy_mode ?? obj?.mode ?? "–");
          const killswitch = (obj?.killswitch ?? obj?.kill_switch);
          const maxOrders = obj?.pm_max_orders_per_tick ?? obj?.max_orders_per_tick;
          const orderSize = obj?.pm_order_size_shares ?? obj?.order_size_shares;

          // Strategy params (preferred when present)
          const drawEdgeMin = tryParseNumber(obj?.pm_draw_edge_min_pct);
          const drawEdgeExit = tryParseNumber(obj?.pm_draw_edge_exit_pct);
          const drawMaxPrice = tryParseNumber(obj?.pm_draw_max_price);
          const drawRequire3way = obj?.pm_draw_require_3way;
          const drawFavMin = tryParseNumber(obj?.pm_draw_fav_min);
          const drawFavMax = tryParseNumber(obj?.pm_draw_fav_max);
          const drawBaselineP = tryParseNumber(obj?.pm_draw_baseline_p);
          const drawBookProbMult = tryParseNumber(obj?.pm_draw_book_prob_mult);
          const drawBaselineFile = obj?.pm_draw_baseline_file;

          const trendLookback = tryParseNumber(obj?.pm_trend_lookback_points);
          const trendMoveMin = tryParseNumber(obj?.pm_trend_move_min_pct);
          const trendExitMoveMin = tryParseNumber(obj?.pm_trend_exit_move_min_pct);
          const trendAutoSide = obj?.pm_trend_auto_side;
          const hasTrendMeta = [trendLookback, trendMoveMin, trendExitMoveMin].some(Number.isFinite) || (trendAutoSide !== null && trendAutoSide !== undefined);

          const hasDrawMeta = Boolean(
            [drawEdgeMin, drawEdgeExit].some(Number.isFinite)
            || Number.isFinite(drawMaxPrice)
            || (drawRequire3way !== null && drawRequire3way !== undefined)
            || [drawFavMin, drawFavMax].some(Number.isFinite)
            || Number.isFinite(drawBaselineP)
            || Number.isFinite(drawBookProbMult)
            || (drawBaselineFile !== null && drawBaselineFile !== undefined && String(drawBaselineFile).trim())
          );

          const netEdgeMin = tryParseNumber(obj?.lead_lag_net_edge_min_pct);
          const spreadCap = tryParseNumber(obj?.lead_lag_spread_cost_cap_pct);
          const minLagMs = tryParseNumber(obj?.lead_lag_min_market_lag_ms);
          const minNotional = tryParseNumber(obj?.lead_lag_min_trade_notional_usdc);
          const hasGates = [netEdgeMin, spreadCap, minLagMs, minNotional].some(Number.isFinite);

          const moveBase = tryParseNumber(obj?.lead_lag_spot_move_min_pct_base);
          const moveDyn = tryParseNumber(obj?.lead_lag_spot_move_min_pct_dynamic);
          const noisePct = tryParseNumber(obj?.lead_lag_spot_noise_pct);
          const spreadCostPct = tryParseNumber(obj?.lead_lag_spread_cost_pct);
          const hasMoveMeta = [moveBase, moveDyn, noisePct, spreadCostPct].some(Number.isFinite);
          const ts = String(obj?.ts ?? obj?.generated_at ?? obj?.updated_at ?? "");
          const tsMs = parseTimestampMs(ts);
          const ageMs = Number.isFinite(tsMs)
            ? Math.max(0, Date.now() - tsMs)
            : (Number.isFinite(lmMs) ? Math.max(0, Date.now() - lmMs) : NaN);
          const rel = Number.isFinite(ageMs) ? formatAge(ageMs) : "–";
          const abs = ts || (Number.isFinite(lmMs) ? formatUtcTimestamp(lmMs) : "–");

          const liveDot = tradingMode.toLowerCase() === "live" ? "bad" : "ok";
          const ksText = (killswitch === null || killswitch === undefined) ? "–" : (killswitch ? "ON" : "OFF");
          const ksCls = (killswitch === null || killswitch === undefined) ? "" : (killswitch ? "num bad" : "num good");

          const gatesHtml = hasGates
            ? (
                '<p class="muted" style="margin-top:10px">Gates (strategy)</p>' +
                '<p class="muted">Net edge min: <span class="mono">' +
                escapeHtml(Number.isFinite(netEdgeMin) ? (netEdgeMin.toFixed(3) + "%") : "–") +
                '</span></p>' +
                '<p class="muted">Spread cap: <span class="mono">' +
                escapeHtml(Number.isFinite(spreadCap) ? (spreadCap.toFixed(3) + "%") : "–") +
                '</span></p>' +
                '<p class="muted">Min market lag: <span class="mono">' +
                escapeHtml(Number.isFinite(minLagMs) ? (String(Math.round(minLagMs)) + "ms") : "–") +
                '</span></p>' +
                '<p class="muted">Min notional: <span class="mono">' +
                escapeHtml(Number.isFinite(minNotional) ? ("$" + fmt2(minNotional)) : "–") +
                '</span></p>'
              )
            : "";

          const drawHtml = hasDrawMeta
            ? (
                '<p class="muted" style="margin-top:10px">pm_draw parameters</p>' +
                '<p class="muted">Edge min: <span class="mono">' +
                escapeHtml(Number.isFinite(drawEdgeMin) ? (drawEdgeMin.toFixed(3) + "%") : "–") +
                '</span></p>' +
                '<p class="muted">Edge exit: <span class="mono">' +
                escapeHtml(Number.isFinite(drawEdgeExit) ? (drawEdgeExit.toFixed(3) + "%") : "–") +
                '</span></p>' +
                '<p class="muted">Max price: <span class="mono">' +
                escapeHtml(Number.isFinite(drawMaxPrice) ? drawMaxPrice.toFixed(4) : "–") +
                '</span></p>' +
                '<p class="muted">Require 3-way: <span class="mono">' +
                escapeHtml((drawRequire3way === null || drawRequire3way === undefined) ? "–" : String(drawRequire3way)) +
                '</span></p>' +
                '<p class="muted">Fav range: <span class="mono">' +
                escapeHtml((Number.isFinite(drawFavMin) || Number.isFinite(drawFavMax))
                  ? `${Number.isFinite(drawFavMin) ? drawFavMin.toFixed(4) : "–"}..${Number.isFinite(drawFavMax) ? drawFavMax.toFixed(4) : "–"}`
                  : "–") +
                '</span></p>' +
                '<p class="muted">Baseline p: <span class="mono">' +
                escapeHtml(Number.isFinite(drawBaselineP) ? `${drawBaselineP.toFixed(4)} (${(drawBaselineP * 100).toFixed(2)}%)` : "–") +
                '</span></p>' +
                '<p class="muted">Book prob mult: <span class="mono">' +
                escapeHtml(Number.isFinite(drawBookProbMult) ? drawBookProbMult.toFixed(4) : "–") +
                '</span></p>' +
                '<p class="muted">Baseline file: <span class="mono">' +
                escapeHtml((drawBaselineFile === null || drawBaselineFile === undefined) ? "–" : String(drawBaselineFile)) +
                '</span></p>'
              )
            : "";

          const trendHtml = hasTrendMeta
            ? (
                '<p class="muted" style="margin-top:10px">pm_trend parameters</p>' +
                '<p class="muted">Lookback points: <span class="mono">' +
                escapeHtml(Number.isFinite(trendLookback) ? String(Math.round(trendLookback)) : "–") +
                '</span></p>' +
                '<p class="muted">Move min: <span class="mono">' +
                escapeHtml(Number.isFinite(trendMoveMin) ? (trendMoveMin.toFixed(3) + "%") : "–") +
                '</span></p>' +
                '<p class="muted">Exit move min: <span class="mono">' +
                escapeHtml(Number.isFinite(trendExitMoveMin) ? (trendExitMoveMin.toFixed(3) + "%") : "–") +
                '</span></p>' +
                '<p class="muted">Auto side: <span class="mono">' +
                escapeHtml((trendAutoSide === null || trendAutoSide === undefined) ? "–" : String(trendAutoSide)) +
                '</span></p>'
              )
            : "";

          const legacyMoveHtml = (!hasTrendMeta && hasMoveMeta)
            ? (
                '<p class="muted" style="margin-top:10px">Move meta (legacy)</p>' +
                '<p class="muted">Move min base: <span class="mono">' +
                escapeHtml(Number.isFinite(moveBase) ? (moveBase.toFixed(3) + "%") : "–") +
                '</span></p>' +
                '<p class="muted">Move min dyn: <span class="mono">' +
                escapeHtml(Number.isFinite(moveDyn) ? (moveDyn.toFixed(3) + "%") : "–") +
                '</span></p>' +
                '<p class="muted">Noise (est): <span class="mono">' +
                escapeHtml(Number.isFinite(noisePct) ? (noisePct.toFixed(3) + "%") : "–") +
                '</span></p>' +
                '<p class="muted">Spread cost (half): <span class="mono">' +
                escapeHtml(Number.isFinite(spreadCostPct) ? (spreadCostPct.toFixed(3) + "%") : "–") +
                '</span></p>'
              )
            : "";

          el.innerHTML = `
            ${renderBlockMetaLine(file, lmMs)}
            <div class="grid">
              <div class="card">
                <h4>Trading mode</h4>
                <p class="pill"><span class="dot ${escapeHtml(liveDot)}"></span><span class="mono">${escapeHtml(tradingMode)}</span></p>
              </div>
              <div class="card">
                <h4>Strategy mode</h4>
                <div class="mono kpi">${escapeHtml(strategyMode)}</div>
                ${gatesHtml}
                ${drawHtml || trendHtml || legacyMoveHtml}
              </div>
              <div class="card">
                <h4>Killswitch</h4>
                <div class="mono kpi ${escapeHtml(ksCls)}">${escapeHtml(ksText)}</div>
              </div>
              <div class="card">
                <h4>PM order size</h4>
                <div class="mono kpi">${escapeHtml(String(orderSize ?? "–"))}</div>
                <p class="muted">shares per order</p>
              </div>
              <div class="card">
                <h4>Max orders per tick</h4>
                <div class="mono kpi">${escapeHtml(String(maxOrders ?? "–"))}</div>
              </div>
              <div class="card">
                <h4>Senast uppdaterad</h4>
                <p class="mono">${escapeHtml(rel)}</p>
                <p class="muted mono">${escapeHtml(abs)}</p>
              </div>
            </div>
          `;
        }catch(e){
          el.innerHTML = `<p class="muted">Kunde inte ladda live-status: <span class="mono">${escapeHtml(String(e))}</span></p>`;
        }
      }

      // Edge calculator
      const edgeCalcBlocks = Array.from(contentEl.querySelectorAll("[data-edge-calculator]"));
      for (const el of edgeCalcBlocks){
        const file = el.getAttribute("data-edge-calculator");
        try{
          const r = await fetch(`./data/${file}`, { cache: "no-store" });
          if (!r.ok) throw new Error(`${file} (${r.status})`);
          const lm = r.headers.get("Last-Modified");
          const lmMs = lm ? new Date(lm).getTime() : NaN;
          const text = await r.text();
          const rows = parseCsv(text);
          if (rows.length < 2){
            el.innerHTML = renderBlockMetaLine(file, lmMs) + `<p class="muted">Ingen data.</p>`;
            continue;
          }

          const head = rows[0].map(h => String(h || "").trim());
          const idx = (name) => head.findIndex(h => h === name);
          const last = rows[rows.length - 1];

          const ts = String(last[idx("ts")] ?? "");
          const market = String(last[idx("market")] ?? "");
          const raw = tryParseNumber(last[idx("raw_edge")]);
          const spread = tryParseNumber(last[idx("spread_cost")]);
          const fees = tryParseNumber(last[idx("fees")]);
          const net = tryParseNumber(last[idx("net_edge")]);
          const status = String(last[idx("execution_status")] ?? "");
          const reason = String(last[idx("reason")] ?? "");
          const reasonHuman = humanizeReason(reason);

          const gross = Number.isFinite(raw) ? Math.abs(raw) : NaN;
          const spreadAbs = Number.isFinite(spread) ? Math.abs(spread) : 0;
          const feesAbs = Number.isFinite(fees) ? Math.abs(fees) : 0;
          const netAbs = Number.isFinite(net) ? Math.abs(net) : 0;

          const pct = (x) => (gross > 0 && Number.isFinite(x)) ? Math.max(0, Math.min(100, (x / gross) * 100)) : 0;
          let wSpread = pct(spreadAbs);
          let wFees = pct(feesAbs);
          let wNet = Math.max(0, 100 - wSpread - wFees);

          // If net edge is negative, show no green segment.
          const netIsGood = Number.isFinite(net) && net > 0;
          if (!netIsGood) wNet = 0;

          const fmt = (n) => Number.isFinite(n) ? `${n.toFixed(3)}%` : "–";
          const netCls = netIsGood ? "num good" : "num warn";
          const segNetCls = netIsGood ? "netpos" : "netneg";
          const statusText = status ? status : (netIsGood ? "TRIGGERED" : "SKIPPED");

          el.innerHTML = `
            ${renderBlockMetaLine(file, lmMs)}
            <div class="edgecalc">
              <div class="row">
                <div>
                  <p class="title"><strong>${escapeHtml(market || "–")}</strong></p>
                  <p class="sub mono">${escapeHtml(ts || "–")}</p>
                </div>
                <div class="net">
                  <div class="label">Netto edge</div>
                  <div class="value mono ${escapeHtml(netCls)}">${escapeHtml(fmt(net))}</div>
                </div>
              </div>
              <div class="edgebar" role="img" aria-label="Brutto edge uppdelad i spread, avgifter och netto">
                <div class="seg spread" style="width:${wSpread.toFixed(2)}%"><span>Spread ${escapeHtml(fmt(-spreadAbs))}</span></div>
                <div class="seg fee" style="width:${wFees.toFixed(2)}%"><span>Fee ${escapeHtml(fmt(-feesAbs))}</span></div>
                <div class="seg ${segNetCls}" style="width:${wNet.toFixed(2)}%"><span>Netto ${escapeHtml(fmt(net))}</span></div>
              </div>
              <div class="foot">
                <div>Brutto: <strong class="mono">${escapeHtml(fmt(raw))}</strong></div>
                <div>Status: <strong>${escapeHtml(statusText)}</strong> <span class="mono">${escapeHtml(reasonHuman ? ("(" + reasonHuman + ")") : "")}</span></div>
              </div>
            </div>
          `;
        }catch(e){
          el.innerHTML = `<p class="muted">Kunde inte ladda edge calculator: <span class="mono">${escapeHtml(String(e))}</span></p>`;
        }
      }

      // Lag vs latency
      const lagBlocks = Array.from(contentEl.querySelectorAll("[data-lag-latency]"));
      for (const el of lagBlocks){
        const file = el.getAttribute("data-lag-latency");
        try{
          const r = await fetch(`./data/${file}`, { cache: "no-store" });
          if (!r.ok) throw new Error(`${file} (${r.status})`);
          const lm = r.headers.get("Last-Modified");
          const lmMs = lm ? new Date(lm).getTime() : NaN;
          const obj = await r.json();

          const lagMs = Number(obj?.market_lag_ms ?? NaN);
          const sysMs = Number(obj?.system_latency_ms ?? NaN);
          const has = Number.isFinite(lagMs) && Number.isFinite(sysMs);
          // Guard: very small lag estimates are often unstable/meaningless (esp right after restart).
          const minMeaningfulLagMs = 100;
          const tooSmallLag = has ? (lagMs >= 0 && lagMs < minMeaningfulLagMs) : false;
          const ok = (has && !tooSmallLag) ? (sysMs < lagMs) : null;

          const ringCls = (vOk) => vOk === null ? "warn" : (vOk ? "good" : "bad");
          const fmtMs = (n) => Number.isFinite(n) ? `${Math.round(n)}ms` : "–";

          el.innerHTML = `
            ${renderBlockMetaLine(file, lmMs)}
            <div class="gauges">
              <div class="gauge">
                <div class="ring ${escapeHtml(ringCls(ok))}"></div>
                <div>
                  <p class="name">Market Lag</p>
                  <p class="val mono">${escapeHtml(fmtMs(lagMs))}</p>
                  <p class="hint">PM eftersläp (est)</p>
                </div>
              </div>
              <div class="gauge">
                <div class="ring ${escapeHtml(ringCls(ok))}"></div>
                <div>
                  <p class="name">System Latency</p>
                  <p class="val mono">${escapeHtml(fmtMs(sysMs))}</p>
                  <p class="hint">Loop → snapshot</p>
                </div>
              </div>
            </div>
            <p class="muted" style="margin-top:10px">Status: <strong>${escapeHtml(ok === null ? (tooSmallLag ? "WARN (lag ~0, osäkert)" : "INGEN DATA") : (ok ? "OK (snabbare än marknaden)" : "SENT (långsammare än marknaden)"))}</strong></p>
          `;
        }catch(e){
          el.innerHTML = `<p class="muted">Kunde inte ladda lag/latency: <span class="mono">${escapeHtml(String(e))}</span></p>`;
        }
      }

      // Missed opportunities (from edge_calculator_live.csv)
      const missedBlocks = Array.from(contentEl.querySelectorAll("[data-missed-opps]"));
      for (const el of missedBlocks){
        const file = el.getAttribute("data-missed-opps");
        const maxRows = parseInt(el.getAttribute("data-max-rows") || "25", 10);
        try{
          const r = await fetch(`./data/${file}`, { cache: "no-store" });
          if (!r.ok) throw new Error(`${file} (${r.status})`);
          const lm = r.headers.get("Last-Modified");
          const lmMs = lm ? new Date(lm).getTime() : NaN;
          const text = await r.text();
          const rows = parseCsv(text);
          if (rows.length < 2){
            el.innerHTML = renderBlockMetaLine(file, lmMs) + `<p class="muted">Ingen data.</p>`;
            continue;
          }
          const head = rows[0];
          const hi = head.map(h => String(h || "").trim());
          const idx = (name) => hi.indexOf(name);
          const iStatus = idx("execution_status");
          const iReason = idx("reason");

          const missed = [rows[0]];
          for (let i = rows.length - 1; i >= 1 && missed.length <= maxRows; i--){
            const rr = rows[i];
            const st = String(rr[iStatus] ?? "").toUpperCase();
            if (st !== "SKIPPED") continue;
            const reason = String(rr[iReason] ?? "");
            if (!reason) continue;
            const rr2 = rr.slice();
            rr2[iReason] = humanizeReason(reason);
            missed.push(rr2);
          }

          el.innerHTML = renderBlockMetaLine(file, lmMs) + renderTableFromRows(missed, maxRows);
        }catch(e){
          el.innerHTML = `<p class="muted">Kunde inte ladda missed opportunities: <span class="mono">${escapeHtml(String(e))}</span></p>`;
        }
      }

      // Make wide tables easy to scroll horizontally (mouse-drag support).
      enableHorizontalDragScroll(contentEl);
    }

    function enableHorizontalDragScroll(rootEl){
      const wraps = Array.from(rootEl.querySelectorAll(".tablewrap"));
      for (const wrap of wraps){
        if (wrap.dataset.dragScrollInit === "1") continue;
        wrap.dataset.dragScrollInit = "1";

        let isDown = false;
        let isDragging = false;
        let startX = 0;
        let startY = 0;
        let startLeft = 0;

        wrap.addEventListener("pointerdown", (e) => {
          if (e.button !== 0) return; // left-click only
          isDown = true;
          isDragging = false;
          startX = e.clientX;
          startY = e.clientY;
          startLeft = wrap.scrollLeft;
          wrap.classList.add("dragging");
          wrap.setPointerCapture(e.pointerId);
        });

        wrap.addEventListener("pointermove", (e) => {
          if (!isDown) return;
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;

          // Only take over if user is primarily moving sideways.
          if (!isDragging){
            if (Math.abs(dx) < 6) return;
            if (Math.abs(dy) > Math.abs(dx)) return;
            isDragging = true;
          }

          e.preventDefault();
          wrap.scrollLeft = startLeft - dx;
        }, { passive: false });

        const end = () => {
          isDown = false;
          isDragging = false;
          wrap.classList.remove("dragging");
        };
        wrap.addEventListener("pointerup", end);
        wrap.addEventListener("pointercancel", end);
        wrap.addEventListener("pointerleave", end);
      }
    }

    // ----------------------------
    // Events
    // ----------------------------
    window.addEventListener("hashchange", render);

    // Init
    buildNav();
    if (!location.hash) location.hash = DEFAULT_ROUTE;
    render();
  </script>
</body>
</html>
